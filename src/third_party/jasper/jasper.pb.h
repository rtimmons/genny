// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: jasper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_jasper_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_jasper_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_jasper_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_jasper_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_jasper_2eproto;
namespace jasper {
class ArchiveOptions;
class ArchiveOptionsDefaultTypeInternal;
extern ArchiveOptionsDefaultTypeInternal _ArchiveOptions_default_instance_;
class BufferOptions;
class BufferOptionsDefaultTypeInternal;
extern BufferOptionsDefaultTypeInternal _BufferOptions_default_instance_;
class BuildOptions;
class BuildOptionsDefaultTypeInternal;
extern BuildOptionsDefaultTypeInternal _BuildOptions_default_instance_;
class BuildloggerOptions;
class BuildloggerOptionsDefaultTypeInternal;
extern BuildloggerOptionsDefaultTypeInternal _BuildloggerOptions_default_instance_;
class BuildloggerURLs;
class BuildloggerURLsDefaultTypeInternal;
extern BuildloggerURLsDefaultTypeInternal _BuildloggerURLs_default_instance_;
class CacheOptions;
class CacheOptionsDefaultTypeInternal;
extern CacheOptionsDefaultTypeInternal _CacheOptions_default_instance_;
class CreateOptions;
class CreateOptionsDefaultTypeInternal;
extern CreateOptionsDefaultTypeInternal _CreateOptions_default_instance_;
class CreateOptions_EnvironmentEntry_DoNotUse;
class CreateOptions_EnvironmentEntry_DoNotUseDefaultTypeInternal;
extern CreateOptions_EnvironmentEntry_DoNotUseDefaultTypeInternal _CreateOptions_EnvironmentEntry_DoNotUse_default_instance_;
class DownloadInfo;
class DownloadInfoDefaultTypeInternal;
extern DownloadInfoDefaultTypeInternal _DownloadInfo_default_instance_;
class Filter;
class FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class JasperProcessID;
class JasperProcessIDDefaultTypeInternal;
extern JasperProcessIDDefaultTypeInternal _JasperProcessID_default_instance_;
class LogOptions;
class LogOptionsDefaultTypeInternal;
extern LogOptionsDefaultTypeInternal _LogOptions_default_instance_;
class Logger;
class LoggerDefaultTypeInternal;
extern LoggerDefaultTypeInternal _Logger_default_instance_;
class MongoDBDownloadOptions;
class MongoDBDownloadOptionsDefaultTypeInternal;
extern MongoDBDownloadOptionsDefaultTypeInternal _MongoDBDownloadOptions_default_instance_;
class OperationOutcome;
class OperationOutcomeDefaultTypeInternal;
extern OperationOutcomeDefaultTypeInternal _OperationOutcome_default_instance_;
class OutputOptions;
class OutputOptionsDefaultTypeInternal;
extern OutputOptionsDefaultTypeInternal _OutputOptions_default_instance_;
class ProcessInfo;
class ProcessInfoDefaultTypeInternal;
extern ProcessInfoDefaultTypeInternal _ProcessInfo_default_instance_;
class ProcessTags;
class ProcessTagsDefaultTypeInternal;
extern ProcessTagsDefaultTypeInternal _ProcessTags_default_instance_;
class SignalProcess;
class SignalProcessDefaultTypeInternal;
extern SignalProcessDefaultTypeInternal _SignalProcess_default_instance_;
class SplunkOptions;
class SplunkOptionsDefaultTypeInternal;
extern SplunkOptionsDefaultTypeInternal _SplunkOptions_default_instance_;
class StatusResponse;
class StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class TagName;
class TagNameDefaultTypeInternal;
extern TagNameDefaultTypeInternal _TagName_default_instance_;
}  // namespace jasper
PROTOBUF_NAMESPACE_OPEN
template<> ::jasper::ArchiveOptions* Arena::CreateMaybeMessage<::jasper::ArchiveOptions>(Arena*);
template<> ::jasper::BufferOptions* Arena::CreateMaybeMessage<::jasper::BufferOptions>(Arena*);
template<> ::jasper::BuildOptions* Arena::CreateMaybeMessage<::jasper::BuildOptions>(Arena*);
template<> ::jasper::BuildloggerOptions* Arena::CreateMaybeMessage<::jasper::BuildloggerOptions>(Arena*);
template<> ::jasper::BuildloggerURLs* Arena::CreateMaybeMessage<::jasper::BuildloggerURLs>(Arena*);
template<> ::jasper::CacheOptions* Arena::CreateMaybeMessage<::jasper::CacheOptions>(Arena*);
template<> ::jasper::CreateOptions* Arena::CreateMaybeMessage<::jasper::CreateOptions>(Arena*);
template<> ::jasper::CreateOptions_EnvironmentEntry_DoNotUse* Arena::CreateMaybeMessage<::jasper::CreateOptions_EnvironmentEntry_DoNotUse>(Arena*);
template<> ::jasper::DownloadInfo* Arena::CreateMaybeMessage<::jasper::DownloadInfo>(Arena*);
template<> ::jasper::Filter* Arena::CreateMaybeMessage<::jasper::Filter>(Arena*);
template<> ::jasper::JasperProcessID* Arena::CreateMaybeMessage<::jasper::JasperProcessID>(Arena*);
template<> ::jasper::LogOptions* Arena::CreateMaybeMessage<::jasper::LogOptions>(Arena*);
template<> ::jasper::Logger* Arena::CreateMaybeMessage<::jasper::Logger>(Arena*);
template<> ::jasper::MongoDBDownloadOptions* Arena::CreateMaybeMessage<::jasper::MongoDBDownloadOptions>(Arena*);
template<> ::jasper::OperationOutcome* Arena::CreateMaybeMessage<::jasper::OperationOutcome>(Arena*);
template<> ::jasper::OutputOptions* Arena::CreateMaybeMessage<::jasper::OutputOptions>(Arena*);
template<> ::jasper::ProcessInfo* Arena::CreateMaybeMessage<::jasper::ProcessInfo>(Arena*);
template<> ::jasper::ProcessTags* Arena::CreateMaybeMessage<::jasper::ProcessTags>(Arena*);
template<> ::jasper::SignalProcess* Arena::CreateMaybeMessage<::jasper::SignalProcess>(Arena*);
template<> ::jasper::SplunkOptions* Arena::CreateMaybeMessage<::jasper::SplunkOptions>(Arena*);
template<> ::jasper::StatusResponse* Arena::CreateMaybeMessage<::jasper::StatusResponse>(Arena*);
template<> ::jasper::TagName* Arena::CreateMaybeMessage<::jasper::TagName>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace jasper {

enum LogType : int {
  LOGUNKNOWN = 0,
  LOGBUILDLOGGERV2 = 1,
  LOGBUILDLOGGERV3 = 2,
  LOGDEFAULT = 3,
  LOGFILE = 4,
  LOGINHERIT = 5,
  LOGSPLUNK = 6,
  LOGSUMOLOGIC = 7,
  LOGINMEMORY = 8,
  LogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogType_IsValid(int value);
constexpr LogType LogType_MIN = LOGUNKNOWN;
constexpr LogType LogType_MAX = LOGINMEMORY;
constexpr int LogType_ARRAYSIZE = LogType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogType_descriptor();
template<typename T>
inline const std::string& LogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogType_descriptor(), enum_t_value);
}
inline bool LogType_Parse(
    const std::string& name, LogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogType>(
    LogType_descriptor(), name, value);
}
enum LogFormat : int {
  LOGFORMATUNKNOWN = 0,
  LOGFORMATDEFAULT = 1,
  LOGFORMATJSON = 2,
  LOGFORMATPLAIN = 3,
  LogFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogFormat_IsValid(int value);
constexpr LogFormat LogFormat_MIN = LOGFORMATUNKNOWN;
constexpr LogFormat LogFormat_MAX = LOGFORMATPLAIN;
constexpr int LogFormat_ARRAYSIZE = LogFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogFormat_descriptor();
template<typename T>
inline const std::string& LogFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogFormat_descriptor(), enum_t_value);
}
inline bool LogFormat_Parse(
    const std::string& name, LogFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogFormat>(
    LogFormat_descriptor(), name, value);
}
enum FilterSpecifications : int {
  ALL = 0,
  RUNNING = 1,
  TERMINATED = 2,
  FAILED = 3,
  SUCCESSFUL = 4,
  FilterSpecifications_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FilterSpecifications_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FilterSpecifications_IsValid(int value);
constexpr FilterSpecifications FilterSpecifications_MIN = ALL;
constexpr FilterSpecifications FilterSpecifications_MAX = SUCCESSFUL;
constexpr int FilterSpecifications_ARRAYSIZE = FilterSpecifications_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterSpecifications_descriptor();
template<typename T>
inline const std::string& FilterSpecifications_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterSpecifications>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterSpecifications_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterSpecifications_descriptor(), enum_t_value);
}
inline bool FilterSpecifications_Parse(
    const std::string& name, FilterSpecifications* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterSpecifications>(
    FilterSpecifications_descriptor(), name, value);
}
enum Signals : int {
  UNKNOWN = 0,
  TERMINATE = 1,
  KILL = 2,
  HANGUP = 3,
  INIT = 4,
  USER1 = 5,
  USER2 = 6,
  Signals_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Signals_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Signals_IsValid(int value);
constexpr Signals Signals_MIN = UNKNOWN;
constexpr Signals Signals_MAX = USER2;
constexpr int Signals_ARRAYSIZE = Signals_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Signals_descriptor();
template<typename T>
inline const std::string& Signals_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Signals>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Signals_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Signals_descriptor(), enum_t_value);
}
inline bool Signals_Parse(
    const std::string& name, Signals* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Signals>(
    Signals_descriptor(), name, value);
}
enum ArchiveFormat : int {
  ARCHIVEUNKNOWN = 0,
  ARCHIVEAUTO = 1,
  ARCHIVETARGZ = 2,
  ARCHIVEZIP = 3,
  ArchiveFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ArchiveFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ArchiveFormat_IsValid(int value);
constexpr ArchiveFormat ArchiveFormat_MIN = ARCHIVEUNKNOWN;
constexpr ArchiveFormat ArchiveFormat_MAX = ARCHIVEZIP;
constexpr int ArchiveFormat_ARRAYSIZE = ArchiveFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArchiveFormat_descriptor();
template<typename T>
inline const std::string& ArchiveFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArchiveFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArchiveFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArchiveFormat_descriptor(), enum_t_value);
}
inline bool ArchiveFormat_Parse(
    const std::string& name, ArchiveFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArchiveFormat>(
    ArchiveFormat_descriptor(), name, value);
}
// ===================================================================

class Logger :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.Logger) */ {
 public:
  Logger();
  virtual ~Logger();

  Logger(const Logger& from);
  Logger(Logger&& from) noexcept
    : Logger() {
    *this = ::std::move(from);
  }

  inline Logger& operator=(const Logger& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logger& operator=(Logger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Logger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logger* internal_default_instance() {
    return reinterpret_cast<const Logger*>(
               &_Logger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Logger& a, Logger& b) {
    a.Swap(&b);
  }
  inline void Swap(Logger* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Logger* New() const final {
    return CreateMaybeMessage<Logger>(nullptr);
  }

  Logger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Logger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Logger& from);
  void MergeFrom(const Logger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.Logger";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogOptionsFieldNumber = 2,
    kLogTypeFieldNumber = 1,
  };
  // .jasper.LogOptions log_options = 2;
  bool has_log_options() const;
  private:
  bool _internal_has_log_options() const;
  public:
  void clear_log_options();
  const ::jasper::LogOptions& log_options() const;
  ::jasper::LogOptions* release_log_options();
  ::jasper::LogOptions* mutable_log_options();
  void set_allocated_log_options(::jasper::LogOptions* log_options);
  private:
  const ::jasper::LogOptions& _internal_log_options() const;
  ::jasper::LogOptions* _internal_mutable_log_options();
  public:

  // .jasper.LogType log_type = 1;
  void clear_log_type();
  ::jasper::LogType log_type() const;
  void set_log_type(::jasper::LogType value);
  private:
  ::jasper::LogType _internal_log_type() const;
  void _internal_set_log_type(::jasper::LogType value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.Logger)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::jasper::LogOptions* log_options_;
  int log_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class OutputOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.OutputOptions) */ {
 public:
  OutputOptions();
  virtual ~OutputOptions();

  OutputOptions(const OutputOptions& from);
  OutputOptions(OutputOptions&& from) noexcept
    : OutputOptions() {
    *this = ::std::move(from);
  }

  inline OutputOptions& operator=(const OutputOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputOptions& operator=(OutputOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OutputOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputOptions* internal_default_instance() {
    return reinterpret_cast<const OutputOptions*>(
               &_OutputOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OutputOptions& a, OutputOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutputOptions* New() const final {
    return CreateMaybeMessage<OutputOptions>(nullptr);
  }

  OutputOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutputOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OutputOptions& from);
  void MergeFrom(const OutputOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.OutputOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoggersFieldNumber = 1,
    kSuppressOutputFieldNumber = 2,
    kSuppressErrorFieldNumber = 3,
    kRedirectOutputToErrorFieldNumber = 4,
    kRedirectErrorToOutputFieldNumber = 5,
  };
  // repeated .jasper.Logger loggers = 1;
  int loggers_size() const;
  private:
  int _internal_loggers_size() const;
  public:
  void clear_loggers();
  ::jasper::Logger* mutable_loggers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::Logger >*
      mutable_loggers();
  private:
  const ::jasper::Logger& _internal_loggers(int index) const;
  ::jasper::Logger* _internal_add_loggers();
  public:
  const ::jasper::Logger& loggers(int index) const;
  ::jasper::Logger* add_loggers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::Logger >&
      loggers() const;

  // bool suppress_output = 2;
  void clear_suppress_output();
  bool suppress_output() const;
  void set_suppress_output(bool value);
  private:
  bool _internal_suppress_output() const;
  void _internal_set_suppress_output(bool value);
  public:

  // bool suppress_error = 3;
  void clear_suppress_error();
  bool suppress_error() const;
  void set_suppress_error(bool value);
  private:
  bool _internal_suppress_error() const;
  void _internal_set_suppress_error(bool value);
  public:

  // bool redirect_output_to_error = 4;
  void clear_redirect_output_to_error();
  bool redirect_output_to_error() const;
  void set_redirect_output_to_error(bool value);
  private:
  bool _internal_redirect_output_to_error() const;
  void _internal_set_redirect_output_to_error(bool value);
  public:

  // bool redirect_error_to_output = 5;
  void clear_redirect_error_to_output();
  bool redirect_error_to_output() const;
  void set_redirect_error_to_output(bool value);
  private:
  bool _internal_redirect_error_to_output() const;
  void _internal_set_redirect_error_to_output(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.OutputOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::Logger > loggers_;
  bool suppress_output_;
  bool suppress_error_;
  bool redirect_output_to_error_;
  bool redirect_error_to_output_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class LogOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.LogOptions) */ {
 public:
  LogOptions();
  virtual ~LogOptions();

  LogOptions(const LogOptions& from);
  LogOptions(LogOptions&& from) noexcept
    : LogOptions() {
    *this = ::std::move(from);
  }

  inline LogOptions& operator=(const LogOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogOptions& operator=(LogOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogOptions* internal_default_instance() {
    return reinterpret_cast<const LogOptions*>(
               &_LogOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LogOptions& a, LogOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(LogOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogOptions* New() const final {
    return CreateMaybeMessage<LogOptions>(nullptr);
  }

  LogOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogOptions& from);
  void MergeFrom(const LogOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.LogOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultPrefixFieldNumber = 3,
    kFileNameFieldNumber = 4,
    kFormatFieldNumber = 5,
    kSumoEndpointFieldNumber = 8,
    kBufferOptionsFieldNumber = 1,
    kBuildloggerOptionsFieldNumber = 2,
    kSplunkOptionsFieldNumber = 7,
    kInMemoryCapFieldNumber = 6,
  };
  // string default_prefix = 3;
  void clear_default_prefix();
  const std::string& default_prefix() const;
  void set_default_prefix(const std::string& value);
  void set_default_prefix(std::string&& value);
  void set_default_prefix(const char* value);
  void set_default_prefix(const char* value, size_t size);
  std::string* mutable_default_prefix();
  std::string* release_default_prefix();
  void set_allocated_default_prefix(std::string* default_prefix);
  private:
  const std::string& _internal_default_prefix() const;
  void _internal_set_default_prefix(const std::string& value);
  std::string* _internal_mutable_default_prefix();
  public:

  // string file_name = 4;
  void clear_file_name();
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string format = 5;
  void clear_format();
  const std::string& format() const;
  void set_format(const std::string& value);
  void set_format(std::string&& value);
  void set_format(const char* value);
  void set_format(const char* value, size_t size);
  std::string* mutable_format();
  std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // string sumo_endpoint = 8;
  void clear_sumo_endpoint();
  const std::string& sumo_endpoint() const;
  void set_sumo_endpoint(const std::string& value);
  void set_sumo_endpoint(std::string&& value);
  void set_sumo_endpoint(const char* value);
  void set_sumo_endpoint(const char* value, size_t size);
  std::string* mutable_sumo_endpoint();
  std::string* release_sumo_endpoint();
  void set_allocated_sumo_endpoint(std::string* sumo_endpoint);
  private:
  const std::string& _internal_sumo_endpoint() const;
  void _internal_set_sumo_endpoint(const std::string& value);
  std::string* _internal_mutable_sumo_endpoint();
  public:

  // .jasper.BufferOptions buffer_options = 1;
  bool has_buffer_options() const;
  private:
  bool _internal_has_buffer_options() const;
  public:
  void clear_buffer_options();
  const ::jasper::BufferOptions& buffer_options() const;
  ::jasper::BufferOptions* release_buffer_options();
  ::jasper::BufferOptions* mutable_buffer_options();
  void set_allocated_buffer_options(::jasper::BufferOptions* buffer_options);
  private:
  const ::jasper::BufferOptions& _internal_buffer_options() const;
  ::jasper::BufferOptions* _internal_mutable_buffer_options();
  public:

  // .jasper.BuildloggerOptions buildlogger_options = 2;
  bool has_buildlogger_options() const;
  private:
  bool _internal_has_buildlogger_options() const;
  public:
  void clear_buildlogger_options();
  const ::jasper::BuildloggerOptions& buildlogger_options() const;
  ::jasper::BuildloggerOptions* release_buildlogger_options();
  ::jasper::BuildloggerOptions* mutable_buildlogger_options();
  void set_allocated_buildlogger_options(::jasper::BuildloggerOptions* buildlogger_options);
  private:
  const ::jasper::BuildloggerOptions& _internal_buildlogger_options() const;
  ::jasper::BuildloggerOptions* _internal_mutable_buildlogger_options();
  public:

  // .jasper.SplunkOptions splunk_options = 7;
  bool has_splunk_options() const;
  private:
  bool _internal_has_splunk_options() const;
  public:
  void clear_splunk_options();
  const ::jasper::SplunkOptions& splunk_options() const;
  ::jasper::SplunkOptions* release_splunk_options();
  ::jasper::SplunkOptions* mutable_splunk_options();
  void set_allocated_splunk_options(::jasper::SplunkOptions* splunk_options);
  private:
  const ::jasper::SplunkOptions& _internal_splunk_options() const;
  ::jasper::SplunkOptions* _internal_mutable_splunk_options();
  public:

  // int64 in_memory_cap = 6;
  void clear_in_memory_cap();
  ::PROTOBUF_NAMESPACE_ID::int64 in_memory_cap() const;
  void set_in_memory_cap(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_in_memory_cap() const;
  void _internal_set_in_memory_cap(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.LogOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sumo_endpoint_;
  ::jasper::BufferOptions* buffer_options_;
  ::jasper::BuildloggerOptions* buildlogger_options_;
  ::jasper::SplunkOptions* splunk_options_;
  ::PROTOBUF_NAMESPACE_ID::int64 in_memory_cap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class BufferOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.BufferOptions) */ {
 public:
  BufferOptions();
  virtual ~BufferOptions();

  BufferOptions(const BufferOptions& from);
  BufferOptions(BufferOptions&& from) noexcept
    : BufferOptions() {
    *this = ::std::move(from);
  }

  inline BufferOptions& operator=(const BufferOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline BufferOptions& operator=(BufferOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BufferOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BufferOptions* internal_default_instance() {
    return reinterpret_cast<const BufferOptions*>(
               &_BufferOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BufferOptions& a, BufferOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(BufferOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BufferOptions* New() const final {
    return CreateMaybeMessage<BufferOptions>(nullptr);
  }

  BufferOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BufferOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BufferOptions& from);
  void MergeFrom(const BufferOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.BufferOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 2,
    kMaxSizeFieldNumber = 3,
    kBufferedFieldNumber = 1,
  };
  // int64 duration = 2;
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::int64 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 max_size = 3;
  void clear_max_size();
  ::PROTOBUF_NAMESPACE_ID::int64 max_size() const;
  void set_max_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_size() const;
  void _internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool buffered = 1;
  void clear_buffered();
  bool buffered() const;
  void set_buffered(bool value);
  private:
  bool _internal_buffered() const;
  void _internal_set_buffered(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.BufferOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_size_;
  bool buffered_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class BuildloggerOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.BuildloggerOptions) */ {
 public:
  BuildloggerOptions();
  virtual ~BuildloggerOptions();

  BuildloggerOptions(const BuildloggerOptions& from);
  BuildloggerOptions(BuildloggerOptions&& from) noexcept
    : BuildloggerOptions() {
    *this = ::std::move(from);
  }

  inline BuildloggerOptions& operator=(const BuildloggerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildloggerOptions& operator=(BuildloggerOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildloggerOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildloggerOptions* internal_default_instance() {
    return reinterpret_cast<const BuildloggerOptions*>(
               &_BuildloggerOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BuildloggerOptions& a, BuildloggerOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildloggerOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildloggerOptions* New() const final {
    return CreateMaybeMessage<BuildloggerOptions>(nullptr);
  }

  BuildloggerOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildloggerOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildloggerOptions& from);
  void MergeFrom(const BuildloggerOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildloggerOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.BuildloggerOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kPhaseFieldNumber = 4,
    kBuilderFieldNumber = 5,
    kTestFieldNumber = 6,
    kCommandFieldNumber = 7,
    kNumberFieldNumber = 3,
    kCreateTestFieldNumber = 1,
  };
  // string url = 2;
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string phase = 4;
  void clear_phase();
  const std::string& phase() const;
  void set_phase(const std::string& value);
  void set_phase(std::string&& value);
  void set_phase(const char* value);
  void set_phase(const char* value, size_t size);
  std::string* mutable_phase();
  std::string* release_phase();
  void set_allocated_phase(std::string* phase);
  private:
  const std::string& _internal_phase() const;
  void _internal_set_phase(const std::string& value);
  std::string* _internal_mutable_phase();
  public:

  // string builder = 5;
  void clear_builder();
  const std::string& builder() const;
  void set_builder(const std::string& value);
  void set_builder(std::string&& value);
  void set_builder(const char* value);
  void set_builder(const char* value, size_t size);
  std::string* mutable_builder();
  std::string* release_builder();
  void set_allocated_builder(std::string* builder);
  private:
  const std::string& _internal_builder() const;
  void _internal_set_builder(const std::string& value);
  std::string* _internal_mutable_builder();
  public:

  // string test = 6;
  void clear_test();
  const std::string& test() const;
  void set_test(const std::string& value);
  void set_test(std::string&& value);
  void set_test(const char* value);
  void set_test(const char* value, size_t size);
  std::string* mutable_test();
  std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // string command = 7;
  void clear_command();
  const std::string& command() const;
  void set_command(const std::string& value);
  void set_command(std::string&& value);
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  std::string* mutable_command();
  std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // int64 number = 3;
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::int64 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool create_test = 1;
  void clear_create_test();
  bool create_test() const;
  void set_create_test(bool value);
  private:
  bool _internal_create_test() const;
  void _internal_set_create_test(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.BuildloggerOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phase_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr builder_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
  ::PROTOBUF_NAMESPACE_ID::int64 number_;
  bool create_test_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class SplunkOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.SplunkOptions) */ {
 public:
  SplunkOptions();
  virtual ~SplunkOptions();

  SplunkOptions(const SplunkOptions& from);
  SplunkOptions(SplunkOptions&& from) noexcept
    : SplunkOptions() {
    *this = ::std::move(from);
  }

  inline SplunkOptions& operator=(const SplunkOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplunkOptions& operator=(SplunkOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SplunkOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplunkOptions* internal_default_instance() {
    return reinterpret_cast<const SplunkOptions*>(
               &_SplunkOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SplunkOptions& a, SplunkOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SplunkOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SplunkOptions* New() const final {
    return CreateMaybeMessage<SplunkOptions>(nullptr);
  }

  SplunkOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SplunkOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SplunkOptions& from);
  void MergeFrom(const SplunkOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplunkOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.SplunkOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kTokenFieldNumber = 2,
    kChannelFieldNumber = 3,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string token = 2;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string channel = 3;
  void clear_channel();
  const std::string& channel() const;
  void set_channel(const std::string& value);
  void set_channel(std::string&& value);
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  std::string* mutable_channel();
  std::string* release_channel();
  void set_allocated_channel(std::string* channel);
  private:
  const std::string& _internal_channel() const;
  void _internal_set_channel(const std::string& value);
  std::string* _internal_mutable_channel();
  public:

  // @@protoc_insertion_point(class_scope:jasper.SplunkOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class CreateOptions_EnvironmentEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateOptions_EnvironmentEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateOptions_EnvironmentEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateOptions_EnvironmentEntry_DoNotUse();
  CreateOptions_EnvironmentEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateOptions_EnvironmentEntry_DoNotUse& other);
  static const CreateOptions_EnvironmentEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateOptions_EnvironmentEntry_DoNotUse*>(&_CreateOptions_EnvironmentEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "jasper.CreateOptions.EnvironmentEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "jasper.CreateOptions.EnvironmentEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[6];
  }

  public:
};

// -------------------------------------------------------------------

class CreateOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.CreateOptions) */ {
 public:
  CreateOptions();
  virtual ~CreateOptions();

  CreateOptions(const CreateOptions& from);
  CreateOptions(CreateOptions&& from) noexcept
    : CreateOptions() {
    *this = ::std::move(from);
  }

  inline CreateOptions& operator=(const CreateOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateOptions& operator=(CreateOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateOptions* internal_default_instance() {
    return reinterpret_cast<const CreateOptions*>(
               &_CreateOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateOptions& a, CreateOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateOptions* New() const final {
    return CreateMaybeMessage<CreateOptions>(nullptr);
  }

  CreateOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateOptions& from);
  void MergeFrom(const CreateOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.CreateOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
    kEnvironmentFieldNumber = 3,
    kTagsFieldNumber = 6,
    kOnSuccessFieldNumber = 7,
    kOnFailureFieldNumber = 8,
    kOnTimeoutFieldNumber = 9,
    kWorkingDirectoryFieldNumber = 2,
    kOutputFieldNumber = 10,
    kTimeoutSecondsFieldNumber = 5,
    kOverrideEnvironFieldNumber = 4,
  };
  // repeated string args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // map<string, string> environment = 3;
  int environment_size() const;
  private:
  int _internal_environment_size() const;
  public:
  void clear_environment();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_environment() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_environment();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      environment() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_environment();

  // repeated string tags = 6;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // repeated .jasper.CreateOptions on_success = 7;
  int on_success_size() const;
  private:
  int _internal_on_success_size() const;
  public:
  void clear_on_success();
  ::jasper::CreateOptions* mutable_on_success(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >*
      mutable_on_success();
  private:
  const ::jasper::CreateOptions& _internal_on_success(int index) const;
  ::jasper::CreateOptions* _internal_add_on_success();
  public:
  const ::jasper::CreateOptions& on_success(int index) const;
  ::jasper::CreateOptions* add_on_success();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >&
      on_success() const;

  // repeated .jasper.CreateOptions on_failure = 8;
  int on_failure_size() const;
  private:
  int _internal_on_failure_size() const;
  public:
  void clear_on_failure();
  ::jasper::CreateOptions* mutable_on_failure(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >*
      mutable_on_failure();
  private:
  const ::jasper::CreateOptions& _internal_on_failure(int index) const;
  ::jasper::CreateOptions* _internal_add_on_failure();
  public:
  const ::jasper::CreateOptions& on_failure(int index) const;
  ::jasper::CreateOptions* add_on_failure();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >&
      on_failure() const;

  // repeated .jasper.CreateOptions on_timeout = 9;
  int on_timeout_size() const;
  private:
  int _internal_on_timeout_size() const;
  public:
  void clear_on_timeout();
  ::jasper::CreateOptions* mutable_on_timeout(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >*
      mutable_on_timeout();
  private:
  const ::jasper::CreateOptions& _internal_on_timeout(int index) const;
  ::jasper::CreateOptions* _internal_add_on_timeout();
  public:
  const ::jasper::CreateOptions& on_timeout(int index) const;
  ::jasper::CreateOptions* add_on_timeout();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >&
      on_timeout() const;

  // string working_directory = 2;
  void clear_working_directory();
  const std::string& working_directory() const;
  void set_working_directory(const std::string& value);
  void set_working_directory(std::string&& value);
  void set_working_directory(const char* value);
  void set_working_directory(const char* value, size_t size);
  std::string* mutable_working_directory();
  std::string* release_working_directory();
  void set_allocated_working_directory(std::string* working_directory);
  private:
  const std::string& _internal_working_directory() const;
  void _internal_set_working_directory(const std::string& value);
  std::string* _internal_mutable_working_directory();
  public:

  // .jasper.OutputOptions output = 10;
  bool has_output() const;
  private:
  bool _internal_has_output() const;
  public:
  void clear_output();
  const ::jasper::OutputOptions& output() const;
  ::jasper::OutputOptions* release_output();
  ::jasper::OutputOptions* mutable_output();
  void set_allocated_output(::jasper::OutputOptions* output);
  private:
  const ::jasper::OutputOptions& _internal_output() const;
  ::jasper::OutputOptions* _internal_mutable_output();
  public:

  // int64 timeout_seconds = 5;
  void clear_timeout_seconds();
  ::PROTOBUF_NAMESPACE_ID::int64 timeout_seconds() const;
  void set_timeout_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timeout_seconds() const;
  void _internal_set_timeout_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool override_environ = 4;
  void clear_override_environ();
  bool override_environ() const;
  void set_override_environ(bool value);
  private:
  bool _internal_override_environ() const;
  void _internal_set_override_environ(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.CreateOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateOptions_EnvironmentEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > environment_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions > on_success_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions > on_failure_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions > on_timeout_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr working_directory_;
  ::jasper::OutputOptions* output_;
  ::PROTOBUF_NAMESPACE_ID::int64 timeout_seconds_;
  bool override_environ_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class ProcessInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.ProcessInfo) */ {
 public:
  ProcessInfo();
  virtual ~ProcessInfo();

  ProcessInfo(const ProcessInfo& from);
  ProcessInfo(ProcessInfo&& from) noexcept
    : ProcessInfo() {
    *this = ::std::move(from);
  }

  inline ProcessInfo& operator=(const ProcessInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessInfo& operator=(ProcessInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcessInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessInfo* internal_default_instance() {
    return reinterpret_cast<const ProcessInfo*>(
               &_ProcessInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProcessInfo& a, ProcessInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessInfo* New() const final {
    return CreateMaybeMessage<ProcessInfo>(nullptr);
  }

  ProcessInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcessInfo& from);
  void MergeFrom(const ProcessInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.ProcessInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHostIdFieldNumber = 3,
    kOptionsFieldNumber = 8,
    kPidFieldNumber = 2,
    kRunningFieldNumber = 4,
    kSuccessfulFieldNumber = 5,
    kCompleteFieldNumber = 6,
    kTimedoutFieldNumber = 7,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string host_id = 3;
  void clear_host_id();
  const std::string& host_id() const;
  void set_host_id(const std::string& value);
  void set_host_id(std::string&& value);
  void set_host_id(const char* value);
  void set_host_id(const char* value, size_t size);
  std::string* mutable_host_id();
  std::string* release_host_id();
  void set_allocated_host_id(std::string* host_id);
  private:
  const std::string& _internal_host_id() const;
  void _internal_set_host_id(const std::string& value);
  std::string* _internal_mutable_host_id();
  public:

  // .jasper.CreateOptions options = 8;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::jasper::CreateOptions& options() const;
  ::jasper::CreateOptions* release_options();
  ::jasper::CreateOptions* mutable_options();
  void set_allocated_options(::jasper::CreateOptions* options);
  private:
  const ::jasper::CreateOptions& _internal_options() const;
  ::jasper::CreateOptions* _internal_mutable_options();
  public:

  // int64 pid = 2;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool running = 4;
  void clear_running();
  bool running() const;
  void set_running(bool value);
  private:
  bool _internal_running() const;
  void _internal_set_running(bool value);
  public:

  // bool successful = 5;
  void clear_successful();
  bool successful() const;
  void set_successful(bool value);
  private:
  bool _internal_successful() const;
  void _internal_set_successful(bool value);
  public:

  // bool complete = 6;
  void clear_complete();
  bool complete() const;
  void set_complete(bool value);
  private:
  bool _internal_complete() const;
  void _internal_set_complete(bool value);
  public:

  // bool timedout = 7;
  void clear_timedout();
  bool timedout() const;
  void set_timedout(bool value);
  private:
  bool _internal_timedout() const;
  void _internal_set_timedout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.ProcessInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_id_;
  ::jasper::CreateOptions* options_;
  ::PROTOBUF_NAMESPACE_ID::int64 pid_;
  bool running_;
  bool successful_;
  bool complete_;
  bool timedout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const final {
    return CreateMaybeMessage<StatusResponse>(nullptr);
  }

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.StatusResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostIdFieldNumber = 1,
    kActiveFieldNumber = 2,
  };
  // string host_id = 1;
  void clear_host_id();
  const std::string& host_id() const;
  void set_host_id(const std::string& value);
  void set_host_id(std::string&& value);
  void set_host_id(const char* value);
  void set_host_id(const char* value, size_t size);
  std::string* mutable_host_id();
  std::string* release_host_id();
  void set_allocated_host_id(std::string* host_id);
  private:
  const std::string& _internal_host_id() const;
  void _internal_set_host_id(const std::string& value);
  std::string* _internal_mutable_host_id();
  public:

  // bool active = 2;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.StatusResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_id_;
  bool active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class Filter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.Filter) */ {
 public:
  Filter();
  virtual ~Filter();

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Filter* New() const final {
    return CreateMaybeMessage<Filter>(nullptr);
  }

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.Filter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // .jasper.FilterSpecifications name = 1;
  void clear_name();
  ::jasper::FilterSpecifications name() const;
  void set_name(::jasper::FilterSpecifications value);
  private:
  ::jasper::FilterSpecifications _internal_name() const;
  void _internal_set_name(::jasper::FilterSpecifications value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.Filter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class SignalProcess :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.SignalProcess) */ {
 public:
  SignalProcess();
  virtual ~SignalProcess();

  SignalProcess(const SignalProcess& from);
  SignalProcess(SignalProcess&& from) noexcept
    : SignalProcess() {
    *this = ::std::move(from);
  }

  inline SignalProcess& operator=(const SignalProcess& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalProcess& operator=(SignalProcess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalProcess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalProcess* internal_default_instance() {
    return reinterpret_cast<const SignalProcess*>(
               &_SignalProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SignalProcess& a, SignalProcess& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalProcess* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalProcess* New() const final {
    return CreateMaybeMessage<SignalProcess>(nullptr);
  }

  SignalProcess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalProcess>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalProcess& from);
  void MergeFrom(const SignalProcess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalProcess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.SignalProcess";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessIDFieldNumber = 1,
    kSignalFieldNumber = 2,
  };
  // .jasper.JasperProcessID ProcessID = 1;
  bool has_processid() const;
  private:
  bool _internal_has_processid() const;
  public:
  void clear_processid();
  const ::jasper::JasperProcessID& processid() const;
  ::jasper::JasperProcessID* release_processid();
  ::jasper::JasperProcessID* mutable_processid();
  void set_allocated_processid(::jasper::JasperProcessID* processid);
  private:
  const ::jasper::JasperProcessID& _internal_processid() const;
  ::jasper::JasperProcessID* _internal_mutable_processid();
  public:

  // .jasper.Signals signal = 2;
  void clear_signal();
  ::jasper::Signals signal() const;
  void set_signal(::jasper::Signals value);
  private:
  ::jasper::Signals _internal_signal() const;
  void _internal_set_signal(::jasper::Signals value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.SignalProcess)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::jasper::JasperProcessID* processid_;
  int signal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class TagName :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.TagName) */ {
 public:
  TagName();
  virtual ~TagName();

  TagName(const TagName& from);
  TagName(TagName&& from) noexcept
    : TagName() {
    *this = ::std::move(from);
  }

  inline TagName& operator=(const TagName& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagName& operator=(TagName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TagName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TagName* internal_default_instance() {
    return reinterpret_cast<const TagName*>(
               &_TagName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TagName& a, TagName& b) {
    a.Swap(&b);
  }
  inline void Swap(TagName* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagName* New() const final {
    return CreateMaybeMessage<TagName>(nullptr);
  }

  TagName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagName>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TagName& from);
  void MergeFrom(const TagName& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.TagName";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:jasper.TagName)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class ProcessTags :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.ProcessTags) */ {
 public:
  ProcessTags();
  virtual ~ProcessTags();

  ProcessTags(const ProcessTags& from);
  ProcessTags(ProcessTags&& from) noexcept
    : ProcessTags() {
    *this = ::std::move(from);
  }

  inline ProcessTags& operator=(const ProcessTags& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessTags& operator=(ProcessTags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcessTags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessTags* internal_default_instance() {
    return reinterpret_cast<const ProcessTags*>(
               &_ProcessTags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProcessTags& a, ProcessTags& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessTags* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessTags* New() const final {
    return CreateMaybeMessage<ProcessTags>(nullptr);
  }

  ProcessTags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessTags>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcessTags& from);
  void MergeFrom(const ProcessTags& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessTags* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.ProcessTags";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 2,
    kProcessIDFieldNumber = 1,
  };
  // repeated string tags = 2;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string processID = 1;
  void clear_processid();
  const std::string& processid() const;
  void set_processid(const std::string& value);
  void set_processid(std::string&& value);
  void set_processid(const char* value);
  void set_processid(const char* value, size_t size);
  std::string* mutable_processid();
  std::string* release_processid();
  void set_allocated_processid(std::string* processid);
  private:
  const std::string& _internal_processid() const;
  void _internal_set_processid(const std::string& value);
  std::string* _internal_mutable_processid();
  public:

  // @@protoc_insertion_point(class_scope:jasper.ProcessTags)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class JasperProcessID :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.JasperProcessID) */ {
 public:
  JasperProcessID();
  virtual ~JasperProcessID();

  JasperProcessID(const JasperProcessID& from);
  JasperProcessID(JasperProcessID&& from) noexcept
    : JasperProcessID() {
    *this = ::std::move(from);
  }

  inline JasperProcessID& operator=(const JasperProcessID& from) {
    CopyFrom(from);
    return *this;
  }
  inline JasperProcessID& operator=(JasperProcessID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JasperProcessID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JasperProcessID* internal_default_instance() {
    return reinterpret_cast<const JasperProcessID*>(
               &_JasperProcessID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(JasperProcessID& a, JasperProcessID& b) {
    a.Swap(&b);
  }
  inline void Swap(JasperProcessID* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JasperProcessID* New() const final {
    return CreateMaybeMessage<JasperProcessID>(nullptr);
  }

  JasperProcessID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JasperProcessID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JasperProcessID& from);
  void MergeFrom(const JasperProcessID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JasperProcessID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.JasperProcessID";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:jasper.JasperProcessID)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class OperationOutcome :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.OperationOutcome) */ {
 public:
  OperationOutcome();
  virtual ~OperationOutcome();

  OperationOutcome(const OperationOutcome& from);
  OperationOutcome(OperationOutcome&& from) noexcept
    : OperationOutcome() {
    *this = ::std::move(from);
  }

  inline OperationOutcome& operator=(const OperationOutcome& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationOutcome& operator=(OperationOutcome&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OperationOutcome& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationOutcome* internal_default_instance() {
    return reinterpret_cast<const OperationOutcome*>(
               &_OperationOutcome_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(OperationOutcome& a, OperationOutcome& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationOutcome* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OperationOutcome* New() const final {
    return CreateMaybeMessage<OperationOutcome>(nullptr);
  }

  OperationOutcome* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OperationOutcome>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OperationOutcome& from);
  void MergeFrom(const OperationOutcome& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationOutcome* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.OperationOutcome";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.OperationOutcome)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class BuildOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.BuildOptions) */ {
 public:
  BuildOptions();
  virtual ~BuildOptions();

  BuildOptions(const BuildOptions& from);
  BuildOptions(BuildOptions&& from) noexcept
    : BuildOptions() {
    *this = ::std::move(from);
  }

  inline BuildOptions& operator=(const BuildOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildOptions& operator=(BuildOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildOptions* internal_default_instance() {
    return reinterpret_cast<const BuildOptions*>(
               &_BuildOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BuildOptions& a, BuildOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildOptions* New() const final {
    return CreateMaybeMessage<BuildOptions>(nullptr);
  }

  BuildOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildOptions& from);
  void MergeFrom(const BuildOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.BuildOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
    kArchFieldNumber = 2,
    kEditionFieldNumber = 3,
    kDebugFieldNumber = 4,
  };
  // string target = 1;
  void clear_target();
  const std::string& target() const;
  void set_target(const std::string& value);
  void set_target(std::string&& value);
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  std::string* mutable_target();
  std::string* release_target();
  void set_allocated_target(std::string* target);
  private:
  const std::string& _internal_target() const;
  void _internal_set_target(const std::string& value);
  std::string* _internal_mutable_target();
  public:

  // string arch = 2;
  void clear_arch();
  const std::string& arch() const;
  void set_arch(const std::string& value);
  void set_arch(std::string&& value);
  void set_arch(const char* value);
  void set_arch(const char* value, size_t size);
  std::string* mutable_arch();
  std::string* release_arch();
  void set_allocated_arch(std::string* arch);
  private:
  const std::string& _internal_arch() const;
  void _internal_set_arch(const std::string& value);
  std::string* _internal_mutable_arch();
  public:

  // string edition = 3;
  void clear_edition();
  const std::string& edition() const;
  void set_edition(const std::string& value);
  void set_edition(std::string&& value);
  void set_edition(const char* value);
  void set_edition(const char* value, size_t size);
  std::string* mutable_edition();
  std::string* release_edition();
  void set_allocated_edition(std::string* edition);
  private:
  const std::string& _internal_edition() const;
  void _internal_set_edition(const std::string& value);
  std::string* _internal_mutable_edition();
  public:

  // bool debug = 4;
  void clear_debug();
  bool debug() const;
  void set_debug(bool value);
  private:
  bool _internal_debug() const;
  void _internal_set_debug(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.BuildOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arch_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edition_;
  bool debug_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class MongoDBDownloadOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.MongoDBDownloadOptions) */ {
 public:
  MongoDBDownloadOptions();
  virtual ~MongoDBDownloadOptions();

  MongoDBDownloadOptions(const MongoDBDownloadOptions& from);
  MongoDBDownloadOptions(MongoDBDownloadOptions&& from) noexcept
    : MongoDBDownloadOptions() {
    *this = ::std::move(from);
  }

  inline MongoDBDownloadOptions& operator=(const MongoDBDownloadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoDBDownloadOptions& operator=(MongoDBDownloadOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MongoDBDownloadOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MongoDBDownloadOptions* internal_default_instance() {
    return reinterpret_cast<const MongoDBDownloadOptions*>(
               &_MongoDBDownloadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MongoDBDownloadOptions& a, MongoDBDownloadOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoDBDownloadOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MongoDBDownloadOptions* New() const final {
    return CreateMaybeMessage<MongoDBDownloadOptions>(nullptr);
  }

  MongoDBDownloadOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MongoDBDownloadOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MongoDBDownloadOptions& from);
  void MergeFrom(const MongoDBDownloadOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoDBDownloadOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.MongoDBDownloadOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReleasesFieldNumber = 3,
    kPathFieldNumber = 2,
    kBuildOptionsFieldNumber = 1,
  };
  // repeated string releases = 3;
  int releases_size() const;
  private:
  int _internal_releases_size() const;
  public:
  void clear_releases();
  const std::string& releases(int index) const;
  std::string* mutable_releases(int index);
  void set_releases(int index, const std::string& value);
  void set_releases(int index, std::string&& value);
  void set_releases(int index, const char* value);
  void set_releases(int index, const char* value, size_t size);
  std::string* add_releases();
  void add_releases(const std::string& value);
  void add_releases(std::string&& value);
  void add_releases(const char* value);
  void add_releases(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& releases() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_releases();
  private:
  const std::string& _internal_releases(int index) const;
  std::string* _internal_add_releases();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .jasper.BuildOptions build_options = 1;
  bool has_build_options() const;
  private:
  bool _internal_has_build_options() const;
  public:
  void clear_build_options();
  const ::jasper::BuildOptions& build_options() const;
  ::jasper::BuildOptions* release_build_options();
  ::jasper::BuildOptions* mutable_build_options();
  void set_allocated_build_options(::jasper::BuildOptions* build_options);
  private:
  const ::jasper::BuildOptions& _internal_build_options() const;
  ::jasper::BuildOptions* _internal_mutable_build_options();
  public:

  // @@protoc_insertion_point(class_scope:jasper.MongoDBDownloadOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> releases_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::jasper::BuildOptions* build_options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class CacheOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.CacheOptions) */ {
 public:
  CacheOptions();
  virtual ~CacheOptions();

  CacheOptions(const CacheOptions& from);
  CacheOptions(CacheOptions&& from) noexcept
    : CacheOptions() {
    *this = ::std::move(from);
  }

  inline CacheOptions& operator=(const CacheOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheOptions& operator=(CacheOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CacheOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CacheOptions* internal_default_instance() {
    return reinterpret_cast<const CacheOptions*>(
               &_CacheOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CacheOptions& a, CacheOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CacheOptions* New() const final {
    return CreateMaybeMessage<CacheOptions>(nullptr);
  }

  CacheOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CacheOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CacheOptions& from);
  void MergeFrom(const CacheOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.CacheOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPruneDelayFieldNumber = 2,
    kMaxSizeFieldNumber = 3,
    kDisabledFieldNumber = 1,
  };
  // int64 prune_delay = 2;
  void clear_prune_delay();
  ::PROTOBUF_NAMESPACE_ID::int64 prune_delay() const;
  void set_prune_delay(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_prune_delay() const;
  void _internal_set_prune_delay(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 max_size = 3;
  void clear_max_size();
  ::PROTOBUF_NAMESPACE_ID::int64 max_size() const;
  void set_max_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_size() const;
  void _internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool disabled = 1;
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.CacheOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 prune_delay_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_size_;
  bool disabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class ArchiveOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.ArchiveOptions) */ {
 public:
  ArchiveOptions();
  virtual ~ArchiveOptions();

  ArchiveOptions(const ArchiveOptions& from);
  ArchiveOptions(ArchiveOptions&& from) noexcept
    : ArchiveOptions() {
    *this = ::std::move(from);
  }

  inline ArchiveOptions& operator=(const ArchiveOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArchiveOptions& operator=(ArchiveOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ArchiveOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArchiveOptions* internal_default_instance() {
    return reinterpret_cast<const ArchiveOptions*>(
               &_ArchiveOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ArchiveOptions& a, ArchiveOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ArchiveOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ArchiveOptions* New() const final {
    return CreateMaybeMessage<ArchiveOptions>(nullptr);
  }

  ArchiveOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ArchiveOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ArchiveOptions& from);
  void MergeFrom(const ArchiveOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArchiveOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.ArchiveOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPathFieldNumber = 3,
    kShouldExtractFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  // string target_path = 3;
  void clear_target_path();
  const std::string& target_path() const;
  void set_target_path(const std::string& value);
  void set_target_path(std::string&& value);
  void set_target_path(const char* value);
  void set_target_path(const char* value, size_t size);
  std::string* mutable_target_path();
  std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);
  private:
  const std::string& _internal_target_path() const;
  void _internal_set_target_path(const std::string& value);
  std::string* _internal_mutable_target_path();
  public:

  // bool should_extract = 1;
  void clear_should_extract();
  bool should_extract() const;
  void set_should_extract(bool value);
  private:
  bool _internal_should_extract() const;
  void _internal_set_should_extract(bool value);
  public:

  // .jasper.ArchiveFormat format = 2;
  void clear_format();
  ::jasper::ArchiveFormat format() const;
  void set_format(::jasper::ArchiveFormat value);
  private:
  ::jasper::ArchiveFormat _internal_format() const;
  void _internal_set_format(::jasper::ArchiveFormat value);
  public:

  // @@protoc_insertion_point(class_scope:jasper.ArchiveOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  bool should_extract_;
  int format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class DownloadInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.DownloadInfo) */ {
 public:
  DownloadInfo();
  virtual ~DownloadInfo();

  DownloadInfo(const DownloadInfo& from);
  DownloadInfo(DownloadInfo&& from) noexcept
    : DownloadInfo() {
    *this = ::std::move(from);
  }

  inline DownloadInfo& operator=(const DownloadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadInfo& operator=(DownloadInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DownloadInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadInfo* internal_default_instance() {
    return reinterpret_cast<const DownloadInfo*>(
               &_DownloadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DownloadInfo& a, DownloadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadInfo* New() const final {
    return CreateMaybeMessage<DownloadInfo>(nullptr);
  }

  DownloadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DownloadInfo& from);
  void MergeFrom(const DownloadInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.DownloadInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kPathFieldNumber = 2,
    kArchiveOptsFieldNumber = 3,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .jasper.ArchiveOptions archive_opts = 3;
  bool has_archive_opts() const;
  private:
  bool _internal_has_archive_opts() const;
  public:
  void clear_archive_opts();
  const ::jasper::ArchiveOptions& archive_opts() const;
  ::jasper::ArchiveOptions* release_archive_opts();
  ::jasper::ArchiveOptions* mutable_archive_opts();
  void set_allocated_archive_opts(::jasper::ArchiveOptions* archive_opts);
  private:
  const ::jasper::ArchiveOptions& _internal_archive_opts() const;
  ::jasper::ArchiveOptions* _internal_mutable_archive_opts();
  public:

  // @@protoc_insertion_point(class_scope:jasper.DownloadInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::jasper::ArchiveOptions* archive_opts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// -------------------------------------------------------------------

class BuildloggerURLs :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jasper.BuildloggerURLs) */ {
 public:
  BuildloggerURLs();
  virtual ~BuildloggerURLs();

  BuildloggerURLs(const BuildloggerURLs& from);
  BuildloggerURLs(BuildloggerURLs&& from) noexcept
    : BuildloggerURLs() {
    *this = ::std::move(from);
  }

  inline BuildloggerURLs& operator=(const BuildloggerURLs& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildloggerURLs& operator=(BuildloggerURLs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildloggerURLs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildloggerURLs* internal_default_instance() {
    return reinterpret_cast<const BuildloggerURLs*>(
               &_BuildloggerURLs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BuildloggerURLs& a, BuildloggerURLs& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildloggerURLs* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuildloggerURLs* New() const final {
    return CreateMaybeMessage<BuildloggerURLs>(nullptr);
  }

  BuildloggerURLs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildloggerURLs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildloggerURLs& from);
  void MergeFrom(const BuildloggerURLs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildloggerURLs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jasper.BuildloggerURLs";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_jasper_2eproto);
    return ::descriptor_table_jasper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 1,
  };
  // repeated string urls = 1;
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // @@protoc_insertion_point(class_scope:jasper.BuildloggerURLs)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_jasper_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Logger

// .jasper.LogType log_type = 1;
inline void Logger::clear_log_type() {
  log_type_ = 0;
}
inline ::jasper::LogType Logger::_internal_log_type() const {
  return static_cast< ::jasper::LogType >(log_type_);
}
inline ::jasper::LogType Logger::log_type() const {
  // @@protoc_insertion_point(field_get:jasper.Logger.log_type)
  return _internal_log_type();
}
inline void Logger::_internal_set_log_type(::jasper::LogType value) {
  
  log_type_ = value;
}
inline void Logger::set_log_type(::jasper::LogType value) {
  _internal_set_log_type(value);
  // @@protoc_insertion_point(field_set:jasper.Logger.log_type)
}

// .jasper.LogOptions log_options = 2;
inline bool Logger::_internal_has_log_options() const {
  return this != internal_default_instance() && log_options_ != nullptr;
}
inline bool Logger::has_log_options() const {
  return _internal_has_log_options();
}
inline void Logger::clear_log_options() {
  if (GetArenaNoVirtual() == nullptr && log_options_ != nullptr) {
    delete log_options_;
  }
  log_options_ = nullptr;
}
inline const ::jasper::LogOptions& Logger::_internal_log_options() const {
  const ::jasper::LogOptions* p = log_options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::LogOptions*>(
      &::jasper::_LogOptions_default_instance_);
}
inline const ::jasper::LogOptions& Logger::log_options() const {
  // @@protoc_insertion_point(field_get:jasper.Logger.log_options)
  return _internal_log_options();
}
inline ::jasper::LogOptions* Logger::release_log_options() {
  // @@protoc_insertion_point(field_release:jasper.Logger.log_options)
  
  ::jasper::LogOptions* temp = log_options_;
  log_options_ = nullptr;
  return temp;
}
inline ::jasper::LogOptions* Logger::_internal_mutable_log_options() {
  
  if (log_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::LogOptions>(GetArenaNoVirtual());
    log_options_ = p;
  }
  return log_options_;
}
inline ::jasper::LogOptions* Logger::mutable_log_options() {
  // @@protoc_insertion_point(field_mutable:jasper.Logger.log_options)
  return _internal_mutable_log_options();
}
inline void Logger::set_allocated_log_options(::jasper::LogOptions* log_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete log_options_;
  }
  if (log_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      log_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_options, submessage_arena);
    }
    
  } else {
    
  }
  log_options_ = log_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.Logger.log_options)
}

// -------------------------------------------------------------------

// OutputOptions

// repeated .jasper.Logger loggers = 1;
inline int OutputOptions::_internal_loggers_size() const {
  return loggers_.size();
}
inline int OutputOptions::loggers_size() const {
  return _internal_loggers_size();
}
inline void OutputOptions::clear_loggers() {
  loggers_.Clear();
}
inline ::jasper::Logger* OutputOptions::mutable_loggers(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.OutputOptions.loggers)
  return loggers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::Logger >*
OutputOptions::mutable_loggers() {
  // @@protoc_insertion_point(field_mutable_list:jasper.OutputOptions.loggers)
  return &loggers_;
}
inline const ::jasper::Logger& OutputOptions::_internal_loggers(int index) const {
  return loggers_.Get(index);
}
inline const ::jasper::Logger& OutputOptions::loggers(int index) const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.loggers)
  return _internal_loggers(index);
}
inline ::jasper::Logger* OutputOptions::_internal_add_loggers() {
  return loggers_.Add();
}
inline ::jasper::Logger* OutputOptions::add_loggers() {
  // @@protoc_insertion_point(field_add:jasper.OutputOptions.loggers)
  return _internal_add_loggers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::Logger >&
OutputOptions::loggers() const {
  // @@protoc_insertion_point(field_list:jasper.OutputOptions.loggers)
  return loggers_;
}

// bool suppress_output = 2;
inline void OutputOptions::clear_suppress_output() {
  suppress_output_ = false;
}
inline bool OutputOptions::_internal_suppress_output() const {
  return suppress_output_;
}
inline bool OutputOptions::suppress_output() const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.suppress_output)
  return _internal_suppress_output();
}
inline void OutputOptions::_internal_set_suppress_output(bool value) {
  
  suppress_output_ = value;
}
inline void OutputOptions::set_suppress_output(bool value) {
  _internal_set_suppress_output(value);
  // @@protoc_insertion_point(field_set:jasper.OutputOptions.suppress_output)
}

// bool suppress_error = 3;
inline void OutputOptions::clear_suppress_error() {
  suppress_error_ = false;
}
inline bool OutputOptions::_internal_suppress_error() const {
  return suppress_error_;
}
inline bool OutputOptions::suppress_error() const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.suppress_error)
  return _internal_suppress_error();
}
inline void OutputOptions::_internal_set_suppress_error(bool value) {
  
  suppress_error_ = value;
}
inline void OutputOptions::set_suppress_error(bool value) {
  _internal_set_suppress_error(value);
  // @@protoc_insertion_point(field_set:jasper.OutputOptions.suppress_error)
}

// bool redirect_output_to_error = 4;
inline void OutputOptions::clear_redirect_output_to_error() {
  redirect_output_to_error_ = false;
}
inline bool OutputOptions::_internal_redirect_output_to_error() const {
  return redirect_output_to_error_;
}
inline bool OutputOptions::redirect_output_to_error() const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.redirect_output_to_error)
  return _internal_redirect_output_to_error();
}
inline void OutputOptions::_internal_set_redirect_output_to_error(bool value) {
  
  redirect_output_to_error_ = value;
}
inline void OutputOptions::set_redirect_output_to_error(bool value) {
  _internal_set_redirect_output_to_error(value);
  // @@protoc_insertion_point(field_set:jasper.OutputOptions.redirect_output_to_error)
}

// bool redirect_error_to_output = 5;
inline void OutputOptions::clear_redirect_error_to_output() {
  redirect_error_to_output_ = false;
}
inline bool OutputOptions::_internal_redirect_error_to_output() const {
  return redirect_error_to_output_;
}
inline bool OutputOptions::redirect_error_to_output() const {
  // @@protoc_insertion_point(field_get:jasper.OutputOptions.redirect_error_to_output)
  return _internal_redirect_error_to_output();
}
inline void OutputOptions::_internal_set_redirect_error_to_output(bool value) {
  
  redirect_error_to_output_ = value;
}
inline void OutputOptions::set_redirect_error_to_output(bool value) {
  _internal_set_redirect_error_to_output(value);
  // @@protoc_insertion_point(field_set:jasper.OutputOptions.redirect_error_to_output)
}

// -------------------------------------------------------------------

// LogOptions

// .jasper.BufferOptions buffer_options = 1;
inline bool LogOptions::_internal_has_buffer_options() const {
  return this != internal_default_instance() && buffer_options_ != nullptr;
}
inline bool LogOptions::has_buffer_options() const {
  return _internal_has_buffer_options();
}
inline void LogOptions::clear_buffer_options() {
  if (GetArenaNoVirtual() == nullptr && buffer_options_ != nullptr) {
    delete buffer_options_;
  }
  buffer_options_ = nullptr;
}
inline const ::jasper::BufferOptions& LogOptions::_internal_buffer_options() const {
  const ::jasper::BufferOptions* p = buffer_options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::BufferOptions*>(
      &::jasper::_BufferOptions_default_instance_);
}
inline const ::jasper::BufferOptions& LogOptions::buffer_options() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.buffer_options)
  return _internal_buffer_options();
}
inline ::jasper::BufferOptions* LogOptions::release_buffer_options() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.buffer_options)
  
  ::jasper::BufferOptions* temp = buffer_options_;
  buffer_options_ = nullptr;
  return temp;
}
inline ::jasper::BufferOptions* LogOptions::_internal_mutable_buffer_options() {
  
  if (buffer_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::BufferOptions>(GetArenaNoVirtual());
    buffer_options_ = p;
  }
  return buffer_options_;
}
inline ::jasper::BufferOptions* LogOptions::mutable_buffer_options() {
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.buffer_options)
  return _internal_mutable_buffer_options();
}
inline void LogOptions::set_allocated_buffer_options(::jasper::BufferOptions* buffer_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete buffer_options_;
  }
  if (buffer_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buffer_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffer_options, submessage_arena);
    }
    
  } else {
    
  }
  buffer_options_ = buffer_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.buffer_options)
}

// .jasper.BuildloggerOptions buildlogger_options = 2;
inline bool LogOptions::_internal_has_buildlogger_options() const {
  return this != internal_default_instance() && buildlogger_options_ != nullptr;
}
inline bool LogOptions::has_buildlogger_options() const {
  return _internal_has_buildlogger_options();
}
inline void LogOptions::clear_buildlogger_options() {
  if (GetArenaNoVirtual() == nullptr && buildlogger_options_ != nullptr) {
    delete buildlogger_options_;
  }
  buildlogger_options_ = nullptr;
}
inline const ::jasper::BuildloggerOptions& LogOptions::_internal_buildlogger_options() const {
  const ::jasper::BuildloggerOptions* p = buildlogger_options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::BuildloggerOptions*>(
      &::jasper::_BuildloggerOptions_default_instance_);
}
inline const ::jasper::BuildloggerOptions& LogOptions::buildlogger_options() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.buildlogger_options)
  return _internal_buildlogger_options();
}
inline ::jasper::BuildloggerOptions* LogOptions::release_buildlogger_options() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.buildlogger_options)
  
  ::jasper::BuildloggerOptions* temp = buildlogger_options_;
  buildlogger_options_ = nullptr;
  return temp;
}
inline ::jasper::BuildloggerOptions* LogOptions::_internal_mutable_buildlogger_options() {
  
  if (buildlogger_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::BuildloggerOptions>(GetArenaNoVirtual());
    buildlogger_options_ = p;
  }
  return buildlogger_options_;
}
inline ::jasper::BuildloggerOptions* LogOptions::mutable_buildlogger_options() {
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.buildlogger_options)
  return _internal_mutable_buildlogger_options();
}
inline void LogOptions::set_allocated_buildlogger_options(::jasper::BuildloggerOptions* buildlogger_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete buildlogger_options_;
  }
  if (buildlogger_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buildlogger_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buildlogger_options, submessage_arena);
    }
    
  } else {
    
  }
  buildlogger_options_ = buildlogger_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.buildlogger_options)
}

// string default_prefix = 3;
inline void LogOptions::clear_default_prefix() {
  default_prefix_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogOptions::default_prefix() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.default_prefix)
  return _internal_default_prefix();
}
inline void LogOptions::set_default_prefix(const std::string& value) {
  _internal_set_default_prefix(value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.default_prefix)
}
inline std::string* LogOptions::mutable_default_prefix() {
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.default_prefix)
  return _internal_mutable_default_prefix();
}
inline const std::string& LogOptions::_internal_default_prefix() const {
  return default_prefix_.GetNoArena();
}
inline void LogOptions::_internal_set_default_prefix(const std::string& value) {
  
  default_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LogOptions::set_default_prefix(std::string&& value) {
  
  default_prefix_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.LogOptions.default_prefix)
}
inline void LogOptions::set_default_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  default_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.LogOptions.default_prefix)
}
inline void LogOptions::set_default_prefix(const char* value, size_t size) {
  
  default_prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.LogOptions.default_prefix)
}
inline std::string* LogOptions::_internal_mutable_default_prefix() {
  
  return default_prefix_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogOptions::release_default_prefix() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.default_prefix)
  
  return default_prefix_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogOptions::set_allocated_default_prefix(std::string* default_prefix) {
  if (default_prefix != nullptr) {
    
  } else {
    
  }
  default_prefix_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_prefix);
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.default_prefix)
}

// string file_name = 4;
inline void LogOptions::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogOptions::file_name() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.file_name)
  return _internal_file_name();
}
inline void LogOptions::set_file_name(const std::string& value) {
  _internal_set_file_name(value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.file_name)
}
inline std::string* LogOptions::mutable_file_name() {
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.file_name)
  return _internal_mutable_file_name();
}
inline const std::string& LogOptions::_internal_file_name() const {
  return file_name_.GetNoArena();
}
inline void LogOptions::_internal_set_file_name(const std::string& value) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LogOptions::set_file_name(std::string&& value) {
  
  file_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.LogOptions.file_name)
}
inline void LogOptions::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.LogOptions.file_name)
}
inline void LogOptions::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.LogOptions.file_name)
}
inline std::string* LogOptions::_internal_mutable_file_name() {
  
  return file_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogOptions::release_file_name() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.file_name)
  
  return file_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogOptions::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.file_name)
}

// string format = 5;
inline void LogOptions::clear_format() {
  format_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogOptions::format() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.format)
  return _internal_format();
}
inline void LogOptions::set_format(const std::string& value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.format)
}
inline std::string* LogOptions::mutable_format() {
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.format)
  return _internal_mutable_format();
}
inline const std::string& LogOptions::_internal_format() const {
  return format_.GetNoArena();
}
inline void LogOptions::_internal_set_format(const std::string& value) {
  
  format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LogOptions::set_format(std::string&& value) {
  
  format_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.LogOptions.format)
}
inline void LogOptions::set_format(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.LogOptions.format)
}
inline void LogOptions::set_format(const char* value, size_t size) {
  
  format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.LogOptions.format)
}
inline std::string* LogOptions::_internal_mutable_format() {
  
  return format_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogOptions::release_format() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.format)
  
  return format_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogOptions::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  format_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), format);
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.format)
}

// int64 in_memory_cap = 6;
inline void LogOptions::clear_in_memory_cap() {
  in_memory_cap_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogOptions::_internal_in_memory_cap() const {
  return in_memory_cap_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogOptions::in_memory_cap() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.in_memory_cap)
  return _internal_in_memory_cap();
}
inline void LogOptions::_internal_set_in_memory_cap(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  in_memory_cap_ = value;
}
inline void LogOptions::set_in_memory_cap(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_in_memory_cap(value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.in_memory_cap)
}

// .jasper.SplunkOptions splunk_options = 7;
inline bool LogOptions::_internal_has_splunk_options() const {
  return this != internal_default_instance() && splunk_options_ != nullptr;
}
inline bool LogOptions::has_splunk_options() const {
  return _internal_has_splunk_options();
}
inline void LogOptions::clear_splunk_options() {
  if (GetArenaNoVirtual() == nullptr && splunk_options_ != nullptr) {
    delete splunk_options_;
  }
  splunk_options_ = nullptr;
}
inline const ::jasper::SplunkOptions& LogOptions::_internal_splunk_options() const {
  const ::jasper::SplunkOptions* p = splunk_options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::SplunkOptions*>(
      &::jasper::_SplunkOptions_default_instance_);
}
inline const ::jasper::SplunkOptions& LogOptions::splunk_options() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.splunk_options)
  return _internal_splunk_options();
}
inline ::jasper::SplunkOptions* LogOptions::release_splunk_options() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.splunk_options)
  
  ::jasper::SplunkOptions* temp = splunk_options_;
  splunk_options_ = nullptr;
  return temp;
}
inline ::jasper::SplunkOptions* LogOptions::_internal_mutable_splunk_options() {
  
  if (splunk_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::SplunkOptions>(GetArenaNoVirtual());
    splunk_options_ = p;
  }
  return splunk_options_;
}
inline ::jasper::SplunkOptions* LogOptions::mutable_splunk_options() {
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.splunk_options)
  return _internal_mutable_splunk_options();
}
inline void LogOptions::set_allocated_splunk_options(::jasper::SplunkOptions* splunk_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete splunk_options_;
  }
  if (splunk_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      splunk_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, splunk_options, submessage_arena);
    }
    
  } else {
    
  }
  splunk_options_ = splunk_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.splunk_options)
}

// string sumo_endpoint = 8;
inline void LogOptions::clear_sumo_endpoint() {
  sumo_endpoint_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogOptions::sumo_endpoint() const {
  // @@protoc_insertion_point(field_get:jasper.LogOptions.sumo_endpoint)
  return _internal_sumo_endpoint();
}
inline void LogOptions::set_sumo_endpoint(const std::string& value) {
  _internal_set_sumo_endpoint(value);
  // @@protoc_insertion_point(field_set:jasper.LogOptions.sumo_endpoint)
}
inline std::string* LogOptions::mutable_sumo_endpoint() {
  // @@protoc_insertion_point(field_mutable:jasper.LogOptions.sumo_endpoint)
  return _internal_mutable_sumo_endpoint();
}
inline const std::string& LogOptions::_internal_sumo_endpoint() const {
  return sumo_endpoint_.GetNoArena();
}
inline void LogOptions::_internal_set_sumo_endpoint(const std::string& value) {
  
  sumo_endpoint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LogOptions::set_sumo_endpoint(std::string&& value) {
  
  sumo_endpoint_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.LogOptions.sumo_endpoint)
}
inline void LogOptions::set_sumo_endpoint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sumo_endpoint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.LogOptions.sumo_endpoint)
}
inline void LogOptions::set_sumo_endpoint(const char* value, size_t size) {
  
  sumo_endpoint_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.LogOptions.sumo_endpoint)
}
inline std::string* LogOptions::_internal_mutable_sumo_endpoint() {
  
  return sumo_endpoint_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogOptions::release_sumo_endpoint() {
  // @@protoc_insertion_point(field_release:jasper.LogOptions.sumo_endpoint)
  
  return sumo_endpoint_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogOptions::set_allocated_sumo_endpoint(std::string* sumo_endpoint) {
  if (sumo_endpoint != nullptr) {
    
  } else {
    
  }
  sumo_endpoint_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sumo_endpoint);
  // @@protoc_insertion_point(field_set_allocated:jasper.LogOptions.sumo_endpoint)
}

// -------------------------------------------------------------------

// BufferOptions

// bool buffered = 1;
inline void BufferOptions::clear_buffered() {
  buffered_ = false;
}
inline bool BufferOptions::_internal_buffered() const {
  return buffered_;
}
inline bool BufferOptions::buffered() const {
  // @@protoc_insertion_point(field_get:jasper.BufferOptions.buffered)
  return _internal_buffered();
}
inline void BufferOptions::_internal_set_buffered(bool value) {
  
  buffered_ = value;
}
inline void BufferOptions::set_buffered(bool value) {
  _internal_set_buffered(value);
  // @@protoc_insertion_point(field_set:jasper.BufferOptions.buffered)
}

// int64 duration = 2;
inline void BufferOptions::clear_duration() {
  duration_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BufferOptions::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BufferOptions::duration() const {
  // @@protoc_insertion_point(field_get:jasper.BufferOptions.duration)
  return _internal_duration();
}
inline void BufferOptions::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  duration_ = value;
}
inline void BufferOptions::set_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:jasper.BufferOptions.duration)
}

// int64 max_size = 3;
inline void BufferOptions::clear_max_size() {
  max_size_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BufferOptions::_internal_max_size() const {
  return max_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BufferOptions::max_size() const {
  // @@protoc_insertion_point(field_get:jasper.BufferOptions.max_size)
  return _internal_max_size();
}
inline void BufferOptions::_internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  max_size_ = value;
}
inline void BufferOptions::set_max_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_size(value);
  // @@protoc_insertion_point(field_set:jasper.BufferOptions.max_size)
}

// -------------------------------------------------------------------

// BuildloggerOptions

// bool create_test = 1;
inline void BuildloggerOptions::clear_create_test() {
  create_test_ = false;
}
inline bool BuildloggerOptions::_internal_create_test() const {
  return create_test_;
}
inline bool BuildloggerOptions::create_test() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.create_test)
  return _internal_create_test();
}
inline void BuildloggerOptions::_internal_set_create_test(bool value) {
  
  create_test_ = value;
}
inline void BuildloggerOptions::set_create_test(bool value) {
  _internal_set_create_test(value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.create_test)
}

// string url = 2;
inline void BuildloggerOptions::clear_url() {
  url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildloggerOptions::url() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.url)
  return _internal_url();
}
inline void BuildloggerOptions::set_url(const std::string& value) {
  _internal_set_url(value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.url)
}
inline std::string* BuildloggerOptions::mutable_url() {
  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.url)
  return _internal_mutable_url();
}
inline const std::string& BuildloggerOptions::_internal_url() const {
  return url_.GetNoArena();
}
inline void BuildloggerOptions::_internal_set_url(const std::string& value) {
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuildloggerOptions::set_url(std::string&& value) {
  
  url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.url)
}
inline void BuildloggerOptions::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.url)
}
inline void BuildloggerOptions::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.url)
}
inline std::string* BuildloggerOptions::_internal_mutable_url() {
  
  return url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildloggerOptions::release_url() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.url)
  
  return url_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.url)
}

// int64 number = 3;
inline void BuildloggerOptions::clear_number() {
  number_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BuildloggerOptions::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BuildloggerOptions::number() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.number)
  return _internal_number();
}
inline void BuildloggerOptions::_internal_set_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  number_ = value;
}
inline void BuildloggerOptions::set_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.number)
}

// string phase = 4;
inline void BuildloggerOptions::clear_phase() {
  phase_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildloggerOptions::phase() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.phase)
  return _internal_phase();
}
inline void BuildloggerOptions::set_phase(const std::string& value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.phase)
}
inline std::string* BuildloggerOptions::mutable_phase() {
  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.phase)
  return _internal_mutable_phase();
}
inline const std::string& BuildloggerOptions::_internal_phase() const {
  return phase_.GetNoArena();
}
inline void BuildloggerOptions::_internal_set_phase(const std::string& value) {
  
  phase_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuildloggerOptions::set_phase(std::string&& value) {
  
  phase_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.phase)
}
inline void BuildloggerOptions::set_phase(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  phase_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.phase)
}
inline void BuildloggerOptions::set_phase(const char* value, size_t size) {
  
  phase_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.phase)
}
inline std::string* BuildloggerOptions::_internal_mutable_phase() {
  
  return phase_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildloggerOptions::release_phase() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.phase)
  
  return phase_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_phase(std::string* phase) {
  if (phase != nullptr) {
    
  } else {
    
  }
  phase_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phase);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.phase)
}

// string builder = 5;
inline void BuildloggerOptions::clear_builder() {
  builder_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildloggerOptions::builder() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.builder)
  return _internal_builder();
}
inline void BuildloggerOptions::set_builder(const std::string& value) {
  _internal_set_builder(value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.builder)
}
inline std::string* BuildloggerOptions::mutable_builder() {
  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.builder)
  return _internal_mutable_builder();
}
inline const std::string& BuildloggerOptions::_internal_builder() const {
  return builder_.GetNoArena();
}
inline void BuildloggerOptions::_internal_set_builder(const std::string& value) {
  
  builder_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuildloggerOptions::set_builder(std::string&& value) {
  
  builder_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.builder)
}
inline void BuildloggerOptions::set_builder(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  builder_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.builder)
}
inline void BuildloggerOptions::set_builder(const char* value, size_t size) {
  
  builder_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.builder)
}
inline std::string* BuildloggerOptions::_internal_mutable_builder() {
  
  return builder_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildloggerOptions::release_builder() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.builder)
  
  return builder_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_builder(std::string* builder) {
  if (builder != nullptr) {
    
  } else {
    
  }
  builder_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), builder);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.builder)
}

// string test = 6;
inline void BuildloggerOptions::clear_test() {
  test_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildloggerOptions::test() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.test)
  return _internal_test();
}
inline void BuildloggerOptions::set_test(const std::string& value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.test)
}
inline std::string* BuildloggerOptions::mutable_test() {
  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.test)
  return _internal_mutable_test();
}
inline const std::string& BuildloggerOptions::_internal_test() const {
  return test_.GetNoArena();
}
inline void BuildloggerOptions::_internal_set_test(const std::string& value) {
  
  test_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuildloggerOptions::set_test(std::string&& value) {
  
  test_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.test)
}
inline void BuildloggerOptions::set_test(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  test_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.test)
}
inline void BuildloggerOptions::set_test(const char* value, size_t size) {
  
  test_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.test)
}
inline std::string* BuildloggerOptions::_internal_mutable_test() {
  
  return test_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildloggerOptions::release_test() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.test)
  
  return test_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    
  } else {
    
  }
  test_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), test);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.test)
}

// string command = 7;
inline void BuildloggerOptions::clear_command() {
  command_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildloggerOptions::command() const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerOptions.command)
  return _internal_command();
}
inline void BuildloggerOptions::set_command(const std::string& value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:jasper.BuildloggerOptions.command)
}
inline std::string* BuildloggerOptions::mutable_command() {
  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerOptions.command)
  return _internal_mutable_command();
}
inline const std::string& BuildloggerOptions::_internal_command() const {
  return command_.GetNoArena();
}
inline void BuildloggerOptions::_internal_set_command(const std::string& value) {
  
  command_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuildloggerOptions::set_command(std::string&& value) {
  
  command_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildloggerOptions.command)
}
inline void BuildloggerOptions::set_command(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  command_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerOptions.command)
}
inline void BuildloggerOptions::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerOptions.command)
}
inline std::string* BuildloggerOptions::_internal_mutable_command() {
  
  return command_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildloggerOptions::release_command() {
  // @@protoc_insertion_point(field_release:jasper.BuildloggerOptions.command)
  
  return command_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildloggerOptions::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildloggerOptions.command)
}

// -------------------------------------------------------------------

// SplunkOptions

// string url = 1;
inline void SplunkOptions::clear_url() {
  url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SplunkOptions::url() const {
  // @@protoc_insertion_point(field_get:jasper.SplunkOptions.url)
  return _internal_url();
}
inline void SplunkOptions::set_url(const std::string& value) {
  _internal_set_url(value);
  // @@protoc_insertion_point(field_set:jasper.SplunkOptions.url)
}
inline std::string* SplunkOptions::mutable_url() {
  // @@protoc_insertion_point(field_mutable:jasper.SplunkOptions.url)
  return _internal_mutable_url();
}
inline const std::string& SplunkOptions::_internal_url() const {
  return url_.GetNoArena();
}
inline void SplunkOptions::_internal_set_url(const std::string& value) {
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SplunkOptions::set_url(std::string&& value) {
  
  url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.SplunkOptions.url)
}
inline void SplunkOptions::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.SplunkOptions.url)
}
inline void SplunkOptions::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.SplunkOptions.url)
}
inline std::string* SplunkOptions::_internal_mutable_url() {
  
  return url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SplunkOptions::release_url() {
  // @@protoc_insertion_point(field_release:jasper.SplunkOptions.url)
  
  return url_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SplunkOptions::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:jasper.SplunkOptions.url)
}

// string token = 2;
inline void SplunkOptions::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SplunkOptions::token() const {
  // @@protoc_insertion_point(field_get:jasper.SplunkOptions.token)
  return _internal_token();
}
inline void SplunkOptions::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:jasper.SplunkOptions.token)
}
inline std::string* SplunkOptions::mutable_token() {
  // @@protoc_insertion_point(field_mutable:jasper.SplunkOptions.token)
  return _internal_mutable_token();
}
inline const std::string& SplunkOptions::_internal_token() const {
  return token_.GetNoArena();
}
inline void SplunkOptions::_internal_set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SplunkOptions::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.SplunkOptions.token)
}
inline void SplunkOptions::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.SplunkOptions.token)
}
inline void SplunkOptions::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.SplunkOptions.token)
}
inline std::string* SplunkOptions::_internal_mutable_token() {
  
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SplunkOptions::release_token() {
  // @@protoc_insertion_point(field_release:jasper.SplunkOptions.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SplunkOptions::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:jasper.SplunkOptions.token)
}

// string channel = 3;
inline void SplunkOptions::clear_channel() {
  channel_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SplunkOptions::channel() const {
  // @@protoc_insertion_point(field_get:jasper.SplunkOptions.channel)
  return _internal_channel();
}
inline void SplunkOptions::set_channel(const std::string& value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:jasper.SplunkOptions.channel)
}
inline std::string* SplunkOptions::mutable_channel() {
  // @@protoc_insertion_point(field_mutable:jasper.SplunkOptions.channel)
  return _internal_mutable_channel();
}
inline const std::string& SplunkOptions::_internal_channel() const {
  return channel_.GetNoArena();
}
inline void SplunkOptions::_internal_set_channel(const std::string& value) {
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SplunkOptions::set_channel(std::string&& value) {
  
  channel_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.SplunkOptions.channel)
}
inline void SplunkOptions::set_channel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.SplunkOptions.channel)
}
inline void SplunkOptions::set_channel(const char* value, size_t size) {
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.SplunkOptions.channel)
}
inline std::string* SplunkOptions::_internal_mutable_channel() {
  
  return channel_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SplunkOptions::release_channel() {
  // @@protoc_insertion_point(field_release:jasper.SplunkOptions.channel)
  
  return channel_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SplunkOptions::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    
  } else {
    
  }
  channel_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:jasper.SplunkOptions.channel)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateOptions

// repeated string args = 1;
inline int CreateOptions::_internal_args_size() const {
  return args_.size();
}
inline int CreateOptions::args_size() const {
  return _internal_args_size();
}
inline void CreateOptions::clear_args() {
  args_.Clear();
}
inline std::string* CreateOptions::add_args() {
  // @@protoc_insertion_point(field_add_mutable:jasper.CreateOptions.args)
  return _internal_add_args();
}
inline const std::string& CreateOptions::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& CreateOptions::args(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.args)
  return _internal_args(index);
}
inline std::string* CreateOptions::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.args)
  return args_.Mutable(index);
}
inline void CreateOptions::set_args(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.args)
  args_.Mutable(index)->assign(value);
}
inline void CreateOptions::set_args(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.args)
  args_.Mutable(index)->assign(std::move(value));
}
inline void CreateOptions::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.CreateOptions.args)
}
inline void CreateOptions::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.CreateOptions.args)
}
inline std::string* CreateOptions::_internal_add_args() {
  return args_.Add();
}
inline void CreateOptions::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.args)
}
inline void CreateOptions::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.args)
}
inline void CreateOptions::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.CreateOptions.args)
}
inline void CreateOptions::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.CreateOptions.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateOptions::args() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateOptions::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.args)
  return &args_;
}

// string working_directory = 2;
inline void CreateOptions::clear_working_directory() {
  working_directory_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CreateOptions::working_directory() const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.working_directory)
  return _internal_working_directory();
}
inline void CreateOptions::set_working_directory(const std::string& value) {
  _internal_set_working_directory(value);
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.working_directory)
}
inline std::string* CreateOptions::mutable_working_directory() {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.working_directory)
  return _internal_mutable_working_directory();
}
inline const std::string& CreateOptions::_internal_working_directory() const {
  return working_directory_.GetNoArena();
}
inline void CreateOptions::_internal_set_working_directory(const std::string& value) {
  
  working_directory_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CreateOptions::set_working_directory(std::string&& value) {
  
  working_directory_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.CreateOptions.working_directory)
}
inline void CreateOptions::set_working_directory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  working_directory_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.CreateOptions.working_directory)
}
inline void CreateOptions::set_working_directory(const char* value, size_t size) {
  
  working_directory_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.CreateOptions.working_directory)
}
inline std::string* CreateOptions::_internal_mutable_working_directory() {
  
  return working_directory_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CreateOptions::release_working_directory() {
  // @@protoc_insertion_point(field_release:jasper.CreateOptions.working_directory)
  
  return working_directory_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CreateOptions::set_allocated_working_directory(std::string* working_directory) {
  if (working_directory != nullptr) {
    
  } else {
    
  }
  working_directory_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), working_directory);
  // @@protoc_insertion_point(field_set_allocated:jasper.CreateOptions.working_directory)
}

// map<string, string> environment = 3;
inline int CreateOptions::_internal_environment_size() const {
  return environment_.size();
}
inline int CreateOptions::environment_size() const {
  return _internal_environment_size();
}
inline void CreateOptions::clear_environment() {
  environment_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateOptions::_internal_environment() const {
  return environment_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateOptions::environment() const {
  // @@protoc_insertion_point(field_map:jasper.CreateOptions.environment)
  return _internal_environment();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateOptions::_internal_mutable_environment() {
  return environment_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateOptions::mutable_environment() {
  // @@protoc_insertion_point(field_mutable_map:jasper.CreateOptions.environment)
  return _internal_mutable_environment();
}

// bool override_environ = 4;
inline void CreateOptions::clear_override_environ() {
  override_environ_ = false;
}
inline bool CreateOptions::_internal_override_environ() const {
  return override_environ_;
}
inline bool CreateOptions::override_environ() const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.override_environ)
  return _internal_override_environ();
}
inline void CreateOptions::_internal_set_override_environ(bool value) {
  
  override_environ_ = value;
}
inline void CreateOptions::set_override_environ(bool value) {
  _internal_set_override_environ(value);
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.override_environ)
}

// int64 timeout_seconds = 5;
inline void CreateOptions::clear_timeout_seconds() {
  timeout_seconds_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateOptions::_internal_timeout_seconds() const {
  return timeout_seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateOptions::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.timeout_seconds)
  return _internal_timeout_seconds();
}
inline void CreateOptions::_internal_set_timeout_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timeout_seconds_ = value;
}
inline void CreateOptions::set_timeout_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.timeout_seconds)
}

// repeated string tags = 6;
inline int CreateOptions::_internal_tags_size() const {
  return tags_.size();
}
inline int CreateOptions::tags_size() const {
  return _internal_tags_size();
}
inline void CreateOptions::clear_tags() {
  tags_.Clear();
}
inline std::string* CreateOptions::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:jasper.CreateOptions.tags)
  return _internal_add_tags();
}
inline const std::string& CreateOptions::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& CreateOptions::tags(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.tags)
  return _internal_tags(index);
}
inline std::string* CreateOptions::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.tags)
  return tags_.Mutable(index);
}
inline void CreateOptions::set_tags(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.tags)
  tags_.Mutable(index)->assign(value);
}
inline void CreateOptions::set_tags(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.CreateOptions.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
inline void CreateOptions::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.CreateOptions.tags)
}
inline void CreateOptions::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.CreateOptions.tags)
}
inline std::string* CreateOptions::_internal_add_tags() {
  return tags_.Add();
}
inline void CreateOptions::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.tags)
}
inline void CreateOptions::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.tags)
}
inline void CreateOptions::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.CreateOptions.tags)
}
inline void CreateOptions::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.CreateOptions.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateOptions::tags() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateOptions::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.tags)
  return &tags_;
}

// repeated .jasper.CreateOptions on_success = 7;
inline int CreateOptions::_internal_on_success_size() const {
  return on_success_.size();
}
inline int CreateOptions::on_success_size() const {
  return _internal_on_success_size();
}
inline void CreateOptions::clear_on_success() {
  on_success_.Clear();
}
inline ::jasper::CreateOptions* CreateOptions::mutable_on_success(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.on_success)
  return on_success_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >*
CreateOptions::mutable_on_success() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.on_success)
  return &on_success_;
}
inline const ::jasper::CreateOptions& CreateOptions::_internal_on_success(int index) const {
  return on_success_.Get(index);
}
inline const ::jasper::CreateOptions& CreateOptions::on_success(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.on_success)
  return _internal_on_success(index);
}
inline ::jasper::CreateOptions* CreateOptions::_internal_add_on_success() {
  return on_success_.Add();
}
inline ::jasper::CreateOptions* CreateOptions::add_on_success() {
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.on_success)
  return _internal_add_on_success();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >&
CreateOptions::on_success() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.on_success)
  return on_success_;
}

// repeated .jasper.CreateOptions on_failure = 8;
inline int CreateOptions::_internal_on_failure_size() const {
  return on_failure_.size();
}
inline int CreateOptions::on_failure_size() const {
  return _internal_on_failure_size();
}
inline void CreateOptions::clear_on_failure() {
  on_failure_.Clear();
}
inline ::jasper::CreateOptions* CreateOptions::mutable_on_failure(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.on_failure)
  return on_failure_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >*
CreateOptions::mutable_on_failure() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.on_failure)
  return &on_failure_;
}
inline const ::jasper::CreateOptions& CreateOptions::_internal_on_failure(int index) const {
  return on_failure_.Get(index);
}
inline const ::jasper::CreateOptions& CreateOptions::on_failure(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.on_failure)
  return _internal_on_failure(index);
}
inline ::jasper::CreateOptions* CreateOptions::_internal_add_on_failure() {
  return on_failure_.Add();
}
inline ::jasper::CreateOptions* CreateOptions::add_on_failure() {
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.on_failure)
  return _internal_add_on_failure();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >&
CreateOptions::on_failure() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.on_failure)
  return on_failure_;
}

// repeated .jasper.CreateOptions on_timeout = 9;
inline int CreateOptions::_internal_on_timeout_size() const {
  return on_timeout_.size();
}
inline int CreateOptions::on_timeout_size() const {
  return _internal_on_timeout_size();
}
inline void CreateOptions::clear_on_timeout() {
  on_timeout_.Clear();
}
inline ::jasper::CreateOptions* CreateOptions::mutable_on_timeout(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.on_timeout)
  return on_timeout_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >*
CreateOptions::mutable_on_timeout() {
  // @@protoc_insertion_point(field_mutable_list:jasper.CreateOptions.on_timeout)
  return &on_timeout_;
}
inline const ::jasper::CreateOptions& CreateOptions::_internal_on_timeout(int index) const {
  return on_timeout_.Get(index);
}
inline const ::jasper::CreateOptions& CreateOptions::on_timeout(int index) const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.on_timeout)
  return _internal_on_timeout(index);
}
inline ::jasper::CreateOptions* CreateOptions::_internal_add_on_timeout() {
  return on_timeout_.Add();
}
inline ::jasper::CreateOptions* CreateOptions::add_on_timeout() {
  // @@protoc_insertion_point(field_add:jasper.CreateOptions.on_timeout)
  return _internal_add_on_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jasper::CreateOptions >&
CreateOptions::on_timeout() const {
  // @@protoc_insertion_point(field_list:jasper.CreateOptions.on_timeout)
  return on_timeout_;
}

// .jasper.OutputOptions output = 10;
inline bool CreateOptions::_internal_has_output() const {
  return this != internal_default_instance() && output_ != nullptr;
}
inline bool CreateOptions::has_output() const {
  return _internal_has_output();
}
inline void CreateOptions::clear_output() {
  if (GetArenaNoVirtual() == nullptr && output_ != nullptr) {
    delete output_;
  }
  output_ = nullptr;
}
inline const ::jasper::OutputOptions& CreateOptions::_internal_output() const {
  const ::jasper::OutputOptions* p = output_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::OutputOptions*>(
      &::jasper::_OutputOptions_default_instance_);
}
inline const ::jasper::OutputOptions& CreateOptions::output() const {
  // @@protoc_insertion_point(field_get:jasper.CreateOptions.output)
  return _internal_output();
}
inline ::jasper::OutputOptions* CreateOptions::release_output() {
  // @@protoc_insertion_point(field_release:jasper.CreateOptions.output)
  
  ::jasper::OutputOptions* temp = output_;
  output_ = nullptr;
  return temp;
}
inline ::jasper::OutputOptions* CreateOptions::_internal_mutable_output() {
  
  if (output_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::OutputOptions>(GetArenaNoVirtual());
    output_ = p;
  }
  return output_;
}
inline ::jasper::OutputOptions* CreateOptions::mutable_output() {
  // @@protoc_insertion_point(field_mutable:jasper.CreateOptions.output)
  return _internal_mutable_output();
}
inline void CreateOptions::set_allocated_output(::jasper::OutputOptions* output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete output_;
  }
  if (output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    
  } else {
    
  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:jasper.CreateOptions.output)
}

// -------------------------------------------------------------------

// ProcessInfo

// string id = 1;
inline void ProcessInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ProcessInfo::id() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.id)
  return _internal_id();
}
inline void ProcessInfo::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.id)
}
inline std::string* ProcessInfo::mutable_id() {
  // @@protoc_insertion_point(field_mutable:jasper.ProcessInfo.id)
  return _internal_mutable_id();
}
inline const std::string& ProcessInfo::_internal_id() const {
  return id_.GetNoArena();
}
inline void ProcessInfo::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ProcessInfo::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.ProcessInfo.id)
}
inline void ProcessInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.ProcessInfo.id)
}
inline void ProcessInfo::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.ProcessInfo.id)
}
inline std::string* ProcessInfo::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ProcessInfo::release_id() {
  // @@protoc_insertion_point(field_release:jasper.ProcessInfo.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:jasper.ProcessInfo.id)
}

// int64 pid = 2;
inline void ProcessInfo::clear_pid() {
  pid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProcessInfo::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProcessInfo::pid() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.pid)
  return _internal_pid();
}
inline void ProcessInfo::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pid_ = value;
}
inline void ProcessInfo::set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.pid)
}

// string host_id = 3;
inline void ProcessInfo::clear_host_id() {
  host_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ProcessInfo::host_id() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.host_id)
  return _internal_host_id();
}
inline void ProcessInfo::set_host_id(const std::string& value) {
  _internal_set_host_id(value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.host_id)
}
inline std::string* ProcessInfo::mutable_host_id() {
  // @@protoc_insertion_point(field_mutable:jasper.ProcessInfo.host_id)
  return _internal_mutable_host_id();
}
inline const std::string& ProcessInfo::_internal_host_id() const {
  return host_id_.GetNoArena();
}
inline void ProcessInfo::_internal_set_host_id(const std::string& value) {
  
  host_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ProcessInfo::set_host_id(std::string&& value) {
  
  host_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.ProcessInfo.host_id)
}
inline void ProcessInfo::set_host_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.ProcessInfo.host_id)
}
inline void ProcessInfo::set_host_id(const char* value, size_t size) {
  
  host_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.ProcessInfo.host_id)
}
inline std::string* ProcessInfo::_internal_mutable_host_id() {
  
  return host_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ProcessInfo::release_host_id() {
  // @@protoc_insertion_point(field_release:jasper.ProcessInfo.host_id)
  
  return host_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessInfo::set_allocated_host_id(std::string* host_id) {
  if (host_id != nullptr) {
    
  } else {
    
  }
  host_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_id);
  // @@protoc_insertion_point(field_set_allocated:jasper.ProcessInfo.host_id)
}

// bool running = 4;
inline void ProcessInfo::clear_running() {
  running_ = false;
}
inline bool ProcessInfo::_internal_running() const {
  return running_;
}
inline bool ProcessInfo::running() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.running)
  return _internal_running();
}
inline void ProcessInfo::_internal_set_running(bool value) {
  
  running_ = value;
}
inline void ProcessInfo::set_running(bool value) {
  _internal_set_running(value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.running)
}

// bool successful = 5;
inline void ProcessInfo::clear_successful() {
  successful_ = false;
}
inline bool ProcessInfo::_internal_successful() const {
  return successful_;
}
inline bool ProcessInfo::successful() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.successful)
  return _internal_successful();
}
inline void ProcessInfo::_internal_set_successful(bool value) {
  
  successful_ = value;
}
inline void ProcessInfo::set_successful(bool value) {
  _internal_set_successful(value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.successful)
}

// bool complete = 6;
inline void ProcessInfo::clear_complete() {
  complete_ = false;
}
inline bool ProcessInfo::_internal_complete() const {
  return complete_;
}
inline bool ProcessInfo::complete() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.complete)
  return _internal_complete();
}
inline void ProcessInfo::_internal_set_complete(bool value) {
  
  complete_ = value;
}
inline void ProcessInfo::set_complete(bool value) {
  _internal_set_complete(value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.complete)
}

// bool timedout = 7;
inline void ProcessInfo::clear_timedout() {
  timedout_ = false;
}
inline bool ProcessInfo::_internal_timedout() const {
  return timedout_;
}
inline bool ProcessInfo::timedout() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.timedout)
  return _internal_timedout();
}
inline void ProcessInfo::_internal_set_timedout(bool value) {
  
  timedout_ = value;
}
inline void ProcessInfo::set_timedout(bool value) {
  _internal_set_timedout(value);
  // @@protoc_insertion_point(field_set:jasper.ProcessInfo.timedout)
}

// .jasper.CreateOptions options = 8;
inline bool ProcessInfo::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool ProcessInfo::has_options() const {
  return _internal_has_options();
}
inline void ProcessInfo::clear_options() {
  if (GetArenaNoVirtual() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::jasper::CreateOptions& ProcessInfo::_internal_options() const {
  const ::jasper::CreateOptions* p = options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::CreateOptions*>(
      &::jasper::_CreateOptions_default_instance_);
}
inline const ::jasper::CreateOptions& ProcessInfo::options() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessInfo.options)
  return _internal_options();
}
inline ::jasper::CreateOptions* ProcessInfo::release_options() {
  // @@protoc_insertion_point(field_release:jasper.ProcessInfo.options)
  
  ::jasper::CreateOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::jasper::CreateOptions* ProcessInfo::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::CreateOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  return options_;
}
inline ::jasper::CreateOptions* ProcessInfo::mutable_options() {
  // @@protoc_insertion_point(field_mutable:jasper.ProcessInfo.options)
  return _internal_mutable_options();
}
inline void ProcessInfo::set_allocated_options(::jasper::CreateOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:jasper.ProcessInfo.options)
}

// -------------------------------------------------------------------

// StatusResponse

// string host_id = 1;
inline void StatusResponse::clear_host_id() {
  host_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StatusResponse::host_id() const {
  // @@protoc_insertion_point(field_get:jasper.StatusResponse.host_id)
  return _internal_host_id();
}
inline void StatusResponse::set_host_id(const std::string& value) {
  _internal_set_host_id(value);
  // @@protoc_insertion_point(field_set:jasper.StatusResponse.host_id)
}
inline std::string* StatusResponse::mutable_host_id() {
  // @@protoc_insertion_point(field_mutable:jasper.StatusResponse.host_id)
  return _internal_mutable_host_id();
}
inline const std::string& StatusResponse::_internal_host_id() const {
  return host_id_.GetNoArena();
}
inline void StatusResponse::_internal_set_host_id(const std::string& value) {
  
  host_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StatusResponse::set_host_id(std::string&& value) {
  
  host_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.StatusResponse.host_id)
}
inline void StatusResponse::set_host_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.StatusResponse.host_id)
}
inline void StatusResponse::set_host_id(const char* value, size_t size) {
  
  host_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.StatusResponse.host_id)
}
inline std::string* StatusResponse::_internal_mutable_host_id() {
  
  return host_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StatusResponse::release_host_id() {
  // @@protoc_insertion_point(field_release:jasper.StatusResponse.host_id)
  
  return host_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_host_id(std::string* host_id) {
  if (host_id != nullptr) {
    
  } else {
    
  }
  host_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_id);
  // @@protoc_insertion_point(field_set_allocated:jasper.StatusResponse.host_id)
}

// bool active = 2;
inline void StatusResponse::clear_active() {
  active_ = false;
}
inline bool StatusResponse::_internal_active() const {
  return active_;
}
inline bool StatusResponse::active() const {
  // @@protoc_insertion_point(field_get:jasper.StatusResponse.active)
  return _internal_active();
}
inline void StatusResponse::_internal_set_active(bool value) {
  
  active_ = value;
}
inline void StatusResponse::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:jasper.StatusResponse.active)
}

// -------------------------------------------------------------------

// Filter

// .jasper.FilterSpecifications name = 1;
inline void Filter::clear_name() {
  name_ = 0;
}
inline ::jasper::FilterSpecifications Filter::_internal_name() const {
  return static_cast< ::jasper::FilterSpecifications >(name_);
}
inline ::jasper::FilterSpecifications Filter::name() const {
  // @@protoc_insertion_point(field_get:jasper.Filter.name)
  return _internal_name();
}
inline void Filter::_internal_set_name(::jasper::FilterSpecifications value) {
  
  name_ = value;
}
inline void Filter::set_name(::jasper::FilterSpecifications value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:jasper.Filter.name)
}

// -------------------------------------------------------------------

// SignalProcess

// .jasper.JasperProcessID ProcessID = 1;
inline bool SignalProcess::_internal_has_processid() const {
  return this != internal_default_instance() && processid_ != nullptr;
}
inline bool SignalProcess::has_processid() const {
  return _internal_has_processid();
}
inline void SignalProcess::clear_processid() {
  if (GetArenaNoVirtual() == nullptr && processid_ != nullptr) {
    delete processid_;
  }
  processid_ = nullptr;
}
inline const ::jasper::JasperProcessID& SignalProcess::_internal_processid() const {
  const ::jasper::JasperProcessID* p = processid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::JasperProcessID*>(
      &::jasper::_JasperProcessID_default_instance_);
}
inline const ::jasper::JasperProcessID& SignalProcess::processid() const {
  // @@protoc_insertion_point(field_get:jasper.SignalProcess.ProcessID)
  return _internal_processid();
}
inline ::jasper::JasperProcessID* SignalProcess::release_processid() {
  // @@protoc_insertion_point(field_release:jasper.SignalProcess.ProcessID)
  
  ::jasper::JasperProcessID* temp = processid_;
  processid_ = nullptr;
  return temp;
}
inline ::jasper::JasperProcessID* SignalProcess::_internal_mutable_processid() {
  
  if (processid_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::JasperProcessID>(GetArenaNoVirtual());
    processid_ = p;
  }
  return processid_;
}
inline ::jasper::JasperProcessID* SignalProcess::mutable_processid() {
  // @@protoc_insertion_point(field_mutable:jasper.SignalProcess.ProcessID)
  return _internal_mutable_processid();
}
inline void SignalProcess::set_allocated_processid(::jasper::JasperProcessID* processid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete processid_;
  }
  if (processid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      processid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processid, submessage_arena);
    }
    
  } else {
    
  }
  processid_ = processid;
  // @@protoc_insertion_point(field_set_allocated:jasper.SignalProcess.ProcessID)
}

// .jasper.Signals signal = 2;
inline void SignalProcess::clear_signal() {
  signal_ = 0;
}
inline ::jasper::Signals SignalProcess::_internal_signal() const {
  return static_cast< ::jasper::Signals >(signal_);
}
inline ::jasper::Signals SignalProcess::signal() const {
  // @@protoc_insertion_point(field_get:jasper.SignalProcess.signal)
  return _internal_signal();
}
inline void SignalProcess::_internal_set_signal(::jasper::Signals value) {
  
  signal_ = value;
}
inline void SignalProcess::set_signal(::jasper::Signals value) {
  _internal_set_signal(value);
  // @@protoc_insertion_point(field_set:jasper.SignalProcess.signal)
}

// -------------------------------------------------------------------

// TagName

// string value = 1;
inline void TagName::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TagName::value() const {
  // @@protoc_insertion_point(field_get:jasper.TagName.value)
  return _internal_value();
}
inline void TagName::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:jasper.TagName.value)
}
inline std::string* TagName::mutable_value() {
  // @@protoc_insertion_point(field_mutable:jasper.TagName.value)
  return _internal_mutable_value();
}
inline const std::string& TagName::_internal_value() const {
  return value_.GetNoArena();
}
inline void TagName::_internal_set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TagName::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.TagName.value)
}
inline void TagName::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.TagName.value)
}
inline void TagName::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.TagName.value)
}
inline std::string* TagName::_internal_mutable_value() {
  
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TagName::release_value() {
  // @@protoc_insertion_point(field_release:jasper.TagName.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TagName::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:jasper.TagName.value)
}

// -------------------------------------------------------------------

// ProcessTags

// string processID = 1;
inline void ProcessTags::clear_processid() {
  processid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ProcessTags::processid() const {
  // @@protoc_insertion_point(field_get:jasper.ProcessTags.processID)
  return _internal_processid();
}
inline void ProcessTags::set_processid(const std::string& value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:jasper.ProcessTags.processID)
}
inline std::string* ProcessTags::mutable_processid() {
  // @@protoc_insertion_point(field_mutable:jasper.ProcessTags.processID)
  return _internal_mutable_processid();
}
inline const std::string& ProcessTags::_internal_processid() const {
  return processid_.GetNoArena();
}
inline void ProcessTags::_internal_set_processid(const std::string& value) {
  
  processid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ProcessTags::set_processid(std::string&& value) {
  
  processid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.ProcessTags.processID)
}
inline void ProcessTags::set_processid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  processid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.ProcessTags.processID)
}
inline void ProcessTags::set_processid(const char* value, size_t size) {
  
  processid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.ProcessTags.processID)
}
inline std::string* ProcessTags::_internal_mutable_processid() {
  
  return processid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ProcessTags::release_processid() {
  // @@protoc_insertion_point(field_release:jasper.ProcessTags.processID)
  
  return processid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessTags::set_allocated_processid(std::string* processid) {
  if (processid != nullptr) {
    
  } else {
    
  }
  processid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), processid);
  // @@protoc_insertion_point(field_set_allocated:jasper.ProcessTags.processID)
}

// repeated string tags = 2;
inline int ProcessTags::_internal_tags_size() const {
  return tags_.size();
}
inline int ProcessTags::tags_size() const {
  return _internal_tags_size();
}
inline void ProcessTags::clear_tags() {
  tags_.Clear();
}
inline std::string* ProcessTags::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:jasper.ProcessTags.tags)
  return _internal_add_tags();
}
inline const std::string& ProcessTags::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& ProcessTags::tags(int index) const {
  // @@protoc_insertion_point(field_get:jasper.ProcessTags.tags)
  return _internal_tags(index);
}
inline std::string* ProcessTags::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.ProcessTags.tags)
  return tags_.Mutable(index);
}
inline void ProcessTags::set_tags(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.ProcessTags.tags)
  tags_.Mutable(index)->assign(value);
}
inline void ProcessTags::set_tags(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.ProcessTags.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
inline void ProcessTags::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.ProcessTags.tags)
}
inline void ProcessTags::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.ProcessTags.tags)
}
inline std::string* ProcessTags::_internal_add_tags() {
  return tags_.Add();
}
inline void ProcessTags::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.ProcessTags.tags)
}
inline void ProcessTags::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.ProcessTags.tags)
}
inline void ProcessTags::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.ProcessTags.tags)
}
inline void ProcessTags::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.ProcessTags.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessTags::tags() const {
  // @@protoc_insertion_point(field_list:jasper.ProcessTags.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessTags::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:jasper.ProcessTags.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// JasperProcessID

// string value = 1;
inline void JasperProcessID::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& JasperProcessID::value() const {
  // @@protoc_insertion_point(field_get:jasper.JasperProcessID.value)
  return _internal_value();
}
inline void JasperProcessID::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:jasper.JasperProcessID.value)
}
inline std::string* JasperProcessID::mutable_value() {
  // @@protoc_insertion_point(field_mutable:jasper.JasperProcessID.value)
  return _internal_mutable_value();
}
inline const std::string& JasperProcessID::_internal_value() const {
  return value_.GetNoArena();
}
inline void JasperProcessID::_internal_set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void JasperProcessID::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.JasperProcessID.value)
}
inline void JasperProcessID::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.JasperProcessID.value)
}
inline void JasperProcessID::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.JasperProcessID.value)
}
inline std::string* JasperProcessID::_internal_mutable_value() {
  
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* JasperProcessID::release_value() {
  // @@protoc_insertion_point(field_release:jasper.JasperProcessID.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void JasperProcessID::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:jasper.JasperProcessID.value)
}

// -------------------------------------------------------------------

// OperationOutcome

// bool success = 1;
inline void OperationOutcome::clear_success() {
  success_ = false;
}
inline bool OperationOutcome::_internal_success() const {
  return success_;
}
inline bool OperationOutcome::success() const {
  // @@protoc_insertion_point(field_get:jasper.OperationOutcome.success)
  return _internal_success();
}
inline void OperationOutcome::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void OperationOutcome::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:jasper.OperationOutcome.success)
}

// string text = 2;
inline void OperationOutcome::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OperationOutcome::text() const {
  // @@protoc_insertion_point(field_get:jasper.OperationOutcome.text)
  return _internal_text();
}
inline void OperationOutcome::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:jasper.OperationOutcome.text)
}
inline std::string* OperationOutcome::mutable_text() {
  // @@protoc_insertion_point(field_mutable:jasper.OperationOutcome.text)
  return _internal_mutable_text();
}
inline const std::string& OperationOutcome::_internal_text() const {
  return text_.GetNoArena();
}
inline void OperationOutcome::_internal_set_text(const std::string& value) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OperationOutcome::set_text(std::string&& value) {
  
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.OperationOutcome.text)
}
inline void OperationOutcome::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.OperationOutcome.text)
}
inline void OperationOutcome::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.OperationOutcome.text)
}
inline std::string* OperationOutcome::_internal_mutable_text() {
  
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OperationOutcome::release_text() {
  // @@protoc_insertion_point(field_release:jasper.OperationOutcome.text)
  
  return text_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OperationOutcome::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:jasper.OperationOutcome.text)
}

// -------------------------------------------------------------------

// BuildOptions

// string target = 1;
inline void BuildOptions::clear_target() {
  target_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildOptions::target() const {
  // @@protoc_insertion_point(field_get:jasper.BuildOptions.target)
  return _internal_target();
}
inline void BuildOptions::set_target(const std::string& value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:jasper.BuildOptions.target)
}
inline std::string* BuildOptions::mutable_target() {
  // @@protoc_insertion_point(field_mutable:jasper.BuildOptions.target)
  return _internal_mutable_target();
}
inline const std::string& BuildOptions::_internal_target() const {
  return target_.GetNoArena();
}
inline void BuildOptions::_internal_set_target(const std::string& value) {
  
  target_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuildOptions::set_target(std::string&& value) {
  
  target_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildOptions.target)
}
inline void BuildOptions::set_target(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildOptions.target)
}
inline void BuildOptions::set_target(const char* value, size_t size) {
  
  target_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildOptions.target)
}
inline std::string* BuildOptions::_internal_mutable_target() {
  
  return target_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildOptions::release_target() {
  // @@protoc_insertion_point(field_release:jasper.BuildOptions.target)
  
  return target_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildOptions::set_allocated_target(std::string* target) {
  if (target != nullptr) {
    
  } else {
    
  }
  target_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildOptions.target)
}

// string arch = 2;
inline void BuildOptions::clear_arch() {
  arch_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildOptions::arch() const {
  // @@protoc_insertion_point(field_get:jasper.BuildOptions.arch)
  return _internal_arch();
}
inline void BuildOptions::set_arch(const std::string& value) {
  _internal_set_arch(value);
  // @@protoc_insertion_point(field_set:jasper.BuildOptions.arch)
}
inline std::string* BuildOptions::mutable_arch() {
  // @@protoc_insertion_point(field_mutable:jasper.BuildOptions.arch)
  return _internal_mutable_arch();
}
inline const std::string& BuildOptions::_internal_arch() const {
  return arch_.GetNoArena();
}
inline void BuildOptions::_internal_set_arch(const std::string& value) {
  
  arch_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuildOptions::set_arch(std::string&& value) {
  
  arch_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildOptions.arch)
}
inline void BuildOptions::set_arch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  arch_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildOptions.arch)
}
inline void BuildOptions::set_arch(const char* value, size_t size) {
  
  arch_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildOptions.arch)
}
inline std::string* BuildOptions::_internal_mutable_arch() {
  
  return arch_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildOptions::release_arch() {
  // @@protoc_insertion_point(field_release:jasper.BuildOptions.arch)
  
  return arch_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildOptions::set_allocated_arch(std::string* arch) {
  if (arch != nullptr) {
    
  } else {
    
  }
  arch_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arch);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildOptions.arch)
}

// string edition = 3;
inline void BuildOptions::clear_edition() {
  edition_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildOptions::edition() const {
  // @@protoc_insertion_point(field_get:jasper.BuildOptions.edition)
  return _internal_edition();
}
inline void BuildOptions::set_edition(const std::string& value) {
  _internal_set_edition(value);
  // @@protoc_insertion_point(field_set:jasper.BuildOptions.edition)
}
inline std::string* BuildOptions::mutable_edition() {
  // @@protoc_insertion_point(field_mutable:jasper.BuildOptions.edition)
  return _internal_mutable_edition();
}
inline const std::string& BuildOptions::_internal_edition() const {
  return edition_.GetNoArena();
}
inline void BuildOptions::_internal_set_edition(const std::string& value) {
  
  edition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuildOptions::set_edition(std::string&& value) {
  
  edition_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.BuildOptions.edition)
}
inline void BuildOptions::set_edition(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  edition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.BuildOptions.edition)
}
inline void BuildOptions::set_edition(const char* value, size_t size) {
  
  edition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildOptions.edition)
}
inline std::string* BuildOptions::_internal_mutable_edition() {
  
  return edition_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildOptions::release_edition() {
  // @@protoc_insertion_point(field_release:jasper.BuildOptions.edition)
  
  return edition_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildOptions::set_allocated_edition(std::string* edition) {
  if (edition != nullptr) {
    
  } else {
    
  }
  edition_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), edition);
  // @@protoc_insertion_point(field_set_allocated:jasper.BuildOptions.edition)
}

// bool debug = 4;
inline void BuildOptions::clear_debug() {
  debug_ = false;
}
inline bool BuildOptions::_internal_debug() const {
  return debug_;
}
inline bool BuildOptions::debug() const {
  // @@protoc_insertion_point(field_get:jasper.BuildOptions.debug)
  return _internal_debug();
}
inline void BuildOptions::_internal_set_debug(bool value) {
  
  debug_ = value;
}
inline void BuildOptions::set_debug(bool value) {
  _internal_set_debug(value);
  // @@protoc_insertion_point(field_set:jasper.BuildOptions.debug)
}

// -------------------------------------------------------------------

// MongoDBDownloadOptions

// .jasper.BuildOptions build_options = 1;
inline bool MongoDBDownloadOptions::_internal_has_build_options() const {
  return this != internal_default_instance() && build_options_ != nullptr;
}
inline bool MongoDBDownloadOptions::has_build_options() const {
  return _internal_has_build_options();
}
inline void MongoDBDownloadOptions::clear_build_options() {
  if (GetArenaNoVirtual() == nullptr && build_options_ != nullptr) {
    delete build_options_;
  }
  build_options_ = nullptr;
}
inline const ::jasper::BuildOptions& MongoDBDownloadOptions::_internal_build_options() const {
  const ::jasper::BuildOptions* p = build_options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::BuildOptions*>(
      &::jasper::_BuildOptions_default_instance_);
}
inline const ::jasper::BuildOptions& MongoDBDownloadOptions::build_options() const {
  // @@protoc_insertion_point(field_get:jasper.MongoDBDownloadOptions.build_options)
  return _internal_build_options();
}
inline ::jasper::BuildOptions* MongoDBDownloadOptions::release_build_options() {
  // @@protoc_insertion_point(field_release:jasper.MongoDBDownloadOptions.build_options)
  
  ::jasper::BuildOptions* temp = build_options_;
  build_options_ = nullptr;
  return temp;
}
inline ::jasper::BuildOptions* MongoDBDownloadOptions::_internal_mutable_build_options() {
  
  if (build_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::BuildOptions>(GetArenaNoVirtual());
    build_options_ = p;
  }
  return build_options_;
}
inline ::jasper::BuildOptions* MongoDBDownloadOptions::mutable_build_options() {
  // @@protoc_insertion_point(field_mutable:jasper.MongoDBDownloadOptions.build_options)
  return _internal_mutable_build_options();
}
inline void MongoDBDownloadOptions::set_allocated_build_options(::jasper::BuildOptions* build_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete build_options_;
  }
  if (build_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      build_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, build_options, submessage_arena);
    }
    
  } else {
    
  }
  build_options_ = build_options;
  // @@protoc_insertion_point(field_set_allocated:jasper.MongoDBDownloadOptions.build_options)
}

// string path = 2;
inline void MongoDBDownloadOptions::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MongoDBDownloadOptions::path() const {
  // @@protoc_insertion_point(field_get:jasper.MongoDBDownloadOptions.path)
  return _internal_path();
}
inline void MongoDBDownloadOptions::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:jasper.MongoDBDownloadOptions.path)
}
inline std::string* MongoDBDownloadOptions::mutable_path() {
  // @@protoc_insertion_point(field_mutable:jasper.MongoDBDownloadOptions.path)
  return _internal_mutable_path();
}
inline const std::string& MongoDBDownloadOptions::_internal_path() const {
  return path_.GetNoArena();
}
inline void MongoDBDownloadOptions::_internal_set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void MongoDBDownloadOptions::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.MongoDBDownloadOptions.path)
}
inline void MongoDBDownloadOptions::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.MongoDBDownloadOptions.path)
}
inline void MongoDBDownloadOptions::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.MongoDBDownloadOptions.path)
}
inline std::string* MongoDBDownloadOptions::_internal_mutable_path() {
  
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MongoDBDownloadOptions::release_path() {
  // @@protoc_insertion_point(field_release:jasper.MongoDBDownloadOptions.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MongoDBDownloadOptions::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:jasper.MongoDBDownloadOptions.path)
}

// repeated string releases = 3;
inline int MongoDBDownloadOptions::_internal_releases_size() const {
  return releases_.size();
}
inline int MongoDBDownloadOptions::releases_size() const {
  return _internal_releases_size();
}
inline void MongoDBDownloadOptions::clear_releases() {
  releases_.Clear();
}
inline std::string* MongoDBDownloadOptions::add_releases() {
  // @@protoc_insertion_point(field_add_mutable:jasper.MongoDBDownloadOptions.releases)
  return _internal_add_releases();
}
inline const std::string& MongoDBDownloadOptions::_internal_releases(int index) const {
  return releases_.Get(index);
}
inline const std::string& MongoDBDownloadOptions::releases(int index) const {
  // @@protoc_insertion_point(field_get:jasper.MongoDBDownloadOptions.releases)
  return _internal_releases(index);
}
inline std::string* MongoDBDownloadOptions::mutable_releases(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.MongoDBDownloadOptions.releases)
  return releases_.Mutable(index);
}
inline void MongoDBDownloadOptions::set_releases(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.MongoDBDownloadOptions.releases)
  releases_.Mutable(index)->assign(value);
}
inline void MongoDBDownloadOptions::set_releases(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.MongoDBDownloadOptions.releases)
  releases_.Mutable(index)->assign(std::move(value));
}
inline void MongoDBDownloadOptions::set_releases(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  releases_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.MongoDBDownloadOptions.releases)
}
inline void MongoDBDownloadOptions::set_releases(int index, const char* value, size_t size) {
  releases_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.MongoDBDownloadOptions.releases)
}
inline std::string* MongoDBDownloadOptions::_internal_add_releases() {
  return releases_.Add();
}
inline void MongoDBDownloadOptions::add_releases(const std::string& value) {
  releases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.MongoDBDownloadOptions.releases)
}
inline void MongoDBDownloadOptions::add_releases(std::string&& value) {
  releases_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.MongoDBDownloadOptions.releases)
}
inline void MongoDBDownloadOptions::add_releases(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  releases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.MongoDBDownloadOptions.releases)
}
inline void MongoDBDownloadOptions::add_releases(const char* value, size_t size) {
  releases_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.MongoDBDownloadOptions.releases)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MongoDBDownloadOptions::releases() const {
  // @@protoc_insertion_point(field_list:jasper.MongoDBDownloadOptions.releases)
  return releases_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MongoDBDownloadOptions::mutable_releases() {
  // @@protoc_insertion_point(field_mutable_list:jasper.MongoDBDownloadOptions.releases)
  return &releases_;
}

// -------------------------------------------------------------------

// CacheOptions

// bool disabled = 1;
inline void CacheOptions::clear_disabled() {
  disabled_ = false;
}
inline bool CacheOptions::_internal_disabled() const {
  return disabled_;
}
inline bool CacheOptions::disabled() const {
  // @@protoc_insertion_point(field_get:jasper.CacheOptions.disabled)
  return _internal_disabled();
}
inline void CacheOptions::_internal_set_disabled(bool value) {
  
  disabled_ = value;
}
inline void CacheOptions::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:jasper.CacheOptions.disabled)
}

// int64 prune_delay = 2;
inline void CacheOptions::clear_prune_delay() {
  prune_delay_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CacheOptions::_internal_prune_delay() const {
  return prune_delay_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CacheOptions::prune_delay() const {
  // @@protoc_insertion_point(field_get:jasper.CacheOptions.prune_delay)
  return _internal_prune_delay();
}
inline void CacheOptions::_internal_set_prune_delay(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  prune_delay_ = value;
}
inline void CacheOptions::set_prune_delay(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_prune_delay(value);
  // @@protoc_insertion_point(field_set:jasper.CacheOptions.prune_delay)
}

// int64 max_size = 3;
inline void CacheOptions::clear_max_size() {
  max_size_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CacheOptions::_internal_max_size() const {
  return max_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CacheOptions::max_size() const {
  // @@protoc_insertion_point(field_get:jasper.CacheOptions.max_size)
  return _internal_max_size();
}
inline void CacheOptions::_internal_set_max_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  max_size_ = value;
}
inline void CacheOptions::set_max_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_size(value);
  // @@protoc_insertion_point(field_set:jasper.CacheOptions.max_size)
}

// -------------------------------------------------------------------

// ArchiveOptions

// bool should_extract = 1;
inline void ArchiveOptions::clear_should_extract() {
  should_extract_ = false;
}
inline bool ArchiveOptions::_internal_should_extract() const {
  return should_extract_;
}
inline bool ArchiveOptions::should_extract() const {
  // @@protoc_insertion_point(field_get:jasper.ArchiveOptions.should_extract)
  return _internal_should_extract();
}
inline void ArchiveOptions::_internal_set_should_extract(bool value) {
  
  should_extract_ = value;
}
inline void ArchiveOptions::set_should_extract(bool value) {
  _internal_set_should_extract(value);
  // @@protoc_insertion_point(field_set:jasper.ArchiveOptions.should_extract)
}

// .jasper.ArchiveFormat format = 2;
inline void ArchiveOptions::clear_format() {
  format_ = 0;
}
inline ::jasper::ArchiveFormat ArchiveOptions::_internal_format() const {
  return static_cast< ::jasper::ArchiveFormat >(format_);
}
inline ::jasper::ArchiveFormat ArchiveOptions::format() const {
  // @@protoc_insertion_point(field_get:jasper.ArchiveOptions.format)
  return _internal_format();
}
inline void ArchiveOptions::_internal_set_format(::jasper::ArchiveFormat value) {
  
  format_ = value;
}
inline void ArchiveOptions::set_format(::jasper::ArchiveFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:jasper.ArchiveOptions.format)
}

// string target_path = 3;
inline void ArchiveOptions::clear_target_path() {
  target_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ArchiveOptions::target_path() const {
  // @@protoc_insertion_point(field_get:jasper.ArchiveOptions.target_path)
  return _internal_target_path();
}
inline void ArchiveOptions::set_target_path(const std::string& value) {
  _internal_set_target_path(value);
  // @@protoc_insertion_point(field_set:jasper.ArchiveOptions.target_path)
}
inline std::string* ArchiveOptions::mutable_target_path() {
  // @@protoc_insertion_point(field_mutable:jasper.ArchiveOptions.target_path)
  return _internal_mutable_target_path();
}
inline const std::string& ArchiveOptions::_internal_target_path() const {
  return target_path_.GetNoArena();
}
inline void ArchiveOptions::_internal_set_target_path(const std::string& value) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ArchiveOptions::set_target_path(std::string&& value) {
  
  target_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.ArchiveOptions.target_path)
}
inline void ArchiveOptions::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.ArchiveOptions.target_path)
}
inline void ArchiveOptions::set_target_path(const char* value, size_t size) {
  
  target_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.ArchiveOptions.target_path)
}
inline std::string* ArchiveOptions::_internal_mutable_target_path() {
  
  return target_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ArchiveOptions::release_target_path() {
  // @@protoc_insertion_point(field_release:jasper.ArchiveOptions.target_path)
  
  return target_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ArchiveOptions::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_path);
  // @@protoc_insertion_point(field_set_allocated:jasper.ArchiveOptions.target_path)
}

// -------------------------------------------------------------------

// DownloadInfo

// string url = 1;
inline void DownloadInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadInfo::url() const {
  // @@protoc_insertion_point(field_get:jasper.DownloadInfo.url)
  return _internal_url();
}
inline void DownloadInfo::set_url(const std::string& value) {
  _internal_set_url(value);
  // @@protoc_insertion_point(field_set:jasper.DownloadInfo.url)
}
inline std::string* DownloadInfo::mutable_url() {
  // @@protoc_insertion_point(field_mutable:jasper.DownloadInfo.url)
  return _internal_mutable_url();
}
inline const std::string& DownloadInfo::_internal_url() const {
  return url_.GetNoArena();
}
inline void DownloadInfo::_internal_set_url(const std::string& value) {
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DownloadInfo::set_url(std::string&& value) {
  
  url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.DownloadInfo.url)
}
inline void DownloadInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.DownloadInfo.url)
}
inline void DownloadInfo::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.DownloadInfo.url)
}
inline std::string* DownloadInfo::_internal_mutable_url() {
  
  return url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadInfo::release_url() {
  // @@protoc_insertion_point(field_release:jasper.DownloadInfo.url)
  
  return url_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:jasper.DownloadInfo.url)
}

// string path = 2;
inline void DownloadInfo::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DownloadInfo::path() const {
  // @@protoc_insertion_point(field_get:jasper.DownloadInfo.path)
  return _internal_path();
}
inline void DownloadInfo::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:jasper.DownloadInfo.path)
}
inline std::string* DownloadInfo::mutable_path() {
  // @@protoc_insertion_point(field_mutable:jasper.DownloadInfo.path)
  return _internal_mutable_path();
}
inline const std::string& DownloadInfo::_internal_path() const {
  return path_.GetNoArena();
}
inline void DownloadInfo::_internal_set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DownloadInfo::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jasper.DownloadInfo.path)
}
inline void DownloadInfo::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jasper.DownloadInfo.path)
}
inline void DownloadInfo::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jasper.DownloadInfo.path)
}
inline std::string* DownloadInfo::_internal_mutable_path() {
  
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DownloadInfo::release_path() {
  // @@protoc_insertion_point(field_release:jasper.DownloadInfo.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DownloadInfo::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:jasper.DownloadInfo.path)
}

// .jasper.ArchiveOptions archive_opts = 3;
inline bool DownloadInfo::_internal_has_archive_opts() const {
  return this != internal_default_instance() && archive_opts_ != nullptr;
}
inline bool DownloadInfo::has_archive_opts() const {
  return _internal_has_archive_opts();
}
inline void DownloadInfo::clear_archive_opts() {
  if (GetArenaNoVirtual() == nullptr && archive_opts_ != nullptr) {
    delete archive_opts_;
  }
  archive_opts_ = nullptr;
}
inline const ::jasper::ArchiveOptions& DownloadInfo::_internal_archive_opts() const {
  const ::jasper::ArchiveOptions* p = archive_opts_;
  return p != nullptr ? *p : *reinterpret_cast<const ::jasper::ArchiveOptions*>(
      &::jasper::_ArchiveOptions_default_instance_);
}
inline const ::jasper::ArchiveOptions& DownloadInfo::archive_opts() const {
  // @@protoc_insertion_point(field_get:jasper.DownloadInfo.archive_opts)
  return _internal_archive_opts();
}
inline ::jasper::ArchiveOptions* DownloadInfo::release_archive_opts() {
  // @@protoc_insertion_point(field_release:jasper.DownloadInfo.archive_opts)
  
  ::jasper::ArchiveOptions* temp = archive_opts_;
  archive_opts_ = nullptr;
  return temp;
}
inline ::jasper::ArchiveOptions* DownloadInfo::_internal_mutable_archive_opts() {
  
  if (archive_opts_ == nullptr) {
    auto* p = CreateMaybeMessage<::jasper::ArchiveOptions>(GetArenaNoVirtual());
    archive_opts_ = p;
  }
  return archive_opts_;
}
inline ::jasper::ArchiveOptions* DownloadInfo::mutable_archive_opts() {
  // @@protoc_insertion_point(field_mutable:jasper.DownloadInfo.archive_opts)
  return _internal_mutable_archive_opts();
}
inline void DownloadInfo::set_allocated_archive_opts(::jasper::ArchiveOptions* archive_opts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete archive_opts_;
  }
  if (archive_opts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      archive_opts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, archive_opts, submessage_arena);
    }
    
  } else {
    
  }
  archive_opts_ = archive_opts;
  // @@protoc_insertion_point(field_set_allocated:jasper.DownloadInfo.archive_opts)
}

// -------------------------------------------------------------------

// BuildloggerURLs

// repeated string urls = 1;
inline int BuildloggerURLs::_internal_urls_size() const {
  return urls_.size();
}
inline int BuildloggerURLs::urls_size() const {
  return _internal_urls_size();
}
inline void BuildloggerURLs::clear_urls() {
  urls_.Clear();
}
inline std::string* BuildloggerURLs::add_urls() {
  // @@protoc_insertion_point(field_add_mutable:jasper.BuildloggerURLs.urls)
  return _internal_add_urls();
}
inline const std::string& BuildloggerURLs::_internal_urls(int index) const {
  return urls_.Get(index);
}
inline const std::string& BuildloggerURLs::urls(int index) const {
  // @@protoc_insertion_point(field_get:jasper.BuildloggerURLs.urls)
  return _internal_urls(index);
}
inline std::string* BuildloggerURLs::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:jasper.BuildloggerURLs.urls)
  return urls_.Mutable(index);
}
inline void BuildloggerURLs::set_urls(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:jasper.BuildloggerURLs.urls)
  urls_.Mutable(index)->assign(value);
}
inline void BuildloggerURLs::set_urls(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:jasper.BuildloggerURLs.urls)
  urls_.Mutable(index)->assign(std::move(value));
}
inline void BuildloggerURLs::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jasper.BuildloggerURLs.urls)
}
inline void BuildloggerURLs::set_urls(int index, const char* value, size_t size) {
  urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jasper.BuildloggerURLs.urls)
}
inline std::string* BuildloggerURLs::_internal_add_urls() {
  return urls_.Add();
}
inline void BuildloggerURLs::add_urls(const std::string& value) {
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jasper.BuildloggerURLs.urls)
}
inline void BuildloggerURLs::add_urls(std::string&& value) {
  urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jasper.BuildloggerURLs.urls)
}
inline void BuildloggerURLs::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jasper.BuildloggerURLs.urls)
}
inline void BuildloggerURLs::add_urls(const char* value, size_t size) {
  urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jasper.BuildloggerURLs.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BuildloggerURLs::urls() const {
  // @@protoc_insertion_point(field_list:jasper.BuildloggerURLs.urls)
  return urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BuildloggerURLs::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:jasper.BuildloggerURLs.urls)
  return &urls_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace jasper

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::jasper::LogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::LogType>() {
  return ::jasper::LogType_descriptor();
}
template <> struct is_proto_enum< ::jasper::LogFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::LogFormat>() {
  return ::jasper::LogFormat_descriptor();
}
template <> struct is_proto_enum< ::jasper::FilterSpecifications> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::FilterSpecifications>() {
  return ::jasper::FilterSpecifications_descriptor();
}
template <> struct is_proto_enum< ::jasper::Signals> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::Signals>() {
  return ::jasper::Signals_descriptor();
}
template <> struct is_proto_enum< ::jasper::ArchiveFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jasper::ArchiveFormat>() {
  return ::jasper::ArchiveFormat_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_jasper_2eproto
